//===== Athena Doc ========================================
//= SeAthena 脚本指令列表
//===== Description =======================================
//= 脚本指令列表
//===== Version ===========================================
//= 1.0.20090807
//=========================================================
//= 1.0 - 标准化文档，整合SeA [Inkfish]
//=========================================================

目录:

0.- 基础知识
1.- 基本指令.
2.- 信息获取类指令.
3.- 检查类指令.	
4.- 玩家相关之类.
5.- 魔物相关指令.
6.- 其他指令.		(已汉化)
7.- 副本系统指令.
8.- 任务系统指令.	(已汉化)
9.- 战场指令
10.- 佣兵指令.
11.- SeA指令.		(已汉化)

=====================
|0.- 基  础  知  识.|
=====================

脚本加载
------------------------

将脚本路径设置在 'conf/map_athena.conf' 以被地图服务器加载，或任何被其加载的.conf
文件，如 'npc/scripts_main.conf'.
格式如下：

npc: <path to a filename>

Any line like this, invoked, ultimately, by 'map_athena.conf' will load up the 
script contained in this file, which will make the script available. No file 
will get loaded twice, to prevent possible errors.

Another configuration file option of relevance is:

delnpc: <path to a filename>

This will unload a specified script filename from memory, which, while 
seemingly useless, may sometimes be required.

Whenever '//' is encountered in a line upon reading, everything beyond this on 
that line is considered to be a comment and is ignored. This works wherever you 
place it.

Upon loading all the files, the server will execute all the top-level commands 
in them. No variables exist yet at this point, no commands can be called other 
than those given in this section. These commands set up the basic server script 
structure - create NPC objects, spawn monster objects, set map flags, etc. No 
code is actually executed at this point except them. The top-level commands the 
scripting are pretty confusing, since they aren't structured like you would 
expect commands, command name first, but rather, normally start with a map name.

What's more confusing about the top-level commands is that most of them use a 
tab symbol to divide their arguments.

To prevent problems and confusion, the tab symbols are written as '%TAB%' 
throughout this document, even though this makes the text a bit less readable. 
Using an invisible symbol to denote arguments is one of the bad things about 
this language, but we're stuck with it for now. :)

顶级指令列表:

** 设置地图标签:

<map name>%TAB%mapflag%TAB%<flag>

This will, upon loading, set a specified map flag on a map you like. These are 
normally in files inside 'conf/mapflag' and are loaded first, so by the time the 
server's up, all the maps have the flags they should have. Map flags determine 
the behavior of the map regarding various common problems, for a better 
explanation, see 'setmapflag'.

** 创建可重生魔物:

<map name>,<x>,<y>,<xs>,<ys>%TAB%monster%TAB%<monster name>%TAB%<mob id>,<amount>,<delay1>,<delay2>,<event>

Map name is the name of the map the monsters will spawn on. x,y are the
coordinates where the mob should spawn. If xs and ys are non-zero, they
specify the diameters of a spawn-rectangle area who's center is x,y.
Putting zeros instead of these coordinates will spawn the monsters randomly.
Note this is only the initial spawn zone, as mobs random-walk, they are free
to move away from their specified spawn region.

Monster name is the name the monsters will have on screen, and has no relation 
whatsoever to their names anywhere else. It's the mob id that counts, which 
identifies monster record in 'mob_db.txt' database of monsters. If the mob name 
is given as "--ja--", the 'japanese name' field from the monster database is 
used, (which, in eAthena, actually contains an english name) if it's "--en--", 
it's the 'english name' from the monster database (which contains an uppercase 
name used to summon the monster with a GM command).

If you add 20000 to the monster ID, the monster will be spawned in a 'big 
version', (monster size class will increase) and if you add 10000, the 'tiny 
version' of the monster will be created. However, this method is deprecated
and not recommended, as the values to add can change at a later time (20000
and 10000 actually stand for 2*MAX_MOB_DB and MAX_MOB_DB respectively, which
is defined on mob.h, and can change in the future as more mobs are created).
The recommended way to change a mob's size is to use the event-field (see
below).

Amount is the amount of monsters that will be spawned when this command is 
executed, it is affected by spawn rates in 'battle_athena.conf'.

Delay1 and delay2 are the monster respawn delays - the first one counts the time 
since a monster defined in this spawn was last respawned and the second one 
counts the time since the monster of this spawn was last killed. Whichever turns 
out to be higher will be used. If the resulting number is smaller than a random 
value between 5 and 10 seconds, this value will be used instead. (Which is 
normally the case if both delay values are zero.) The times are given in
1/1000ths of a second.

You can specify a custom level to use for the mob different from the one of
the database by adjoining the level after the name with a comma. eg:
"Poring,50" for a name will spawn a monster with name Poring and level 50.

Event is a script event to be executed when the mob is killed. The event must
be in the form "NPCName::OnEventName" to execute, and the event name label
should start with "On". As with all events, if the NPC is an on-touch NPC, the
player who triggers the script must be within 'trigger' range for the event to
work.

The Event field can be used alternatively to specify other mob properties. Use
2 to specify that the mob should be small, 4 for big monsters, and 8 for
special ai mobs (which by default attack other monsters instead of players).
You can add these, so using 10 will spawn small monsters that attack other
mobs (if you specify both 2 and 4, the small version takes priority).

** NPC名字

/!\ WARNING: this applies to warps, NPCs, duplicates and shops /!\

NPC names are kinda special and are formatted this way:

<Display name>{::<Unique name>}

All NPCs need to have a unique name that is used for identification purposes.
When you have to identify a NPC by it's name, you should use <Unique name>.
If <Unique name> is not provided, use <Display name> instead.

The client has a special feature when displaying names:
if the display name contains a '#' character, it hides that part of the name.
ex: if your NPC is named 'Hunter#hunter1', it will be displayed as 'Hunter'

<Display name> must be at most 24 characters in length.
<Unique name> must be at most 24 characters in length.

** 定义传送点

<from map name>,<fromX>,<fromY>,<facing>%TAB%warp%TAB%<warp name>%TAB%<spanx>,<spany>,<to map name>,<toX>,<toY>

This will define a warp NPC that will warp a player between maps, and while most 
arguments of that are obvious, some deserve special mention.

SpanX and SpanY will make the warp sensitive to a character who didn't step 
directly on it, but walked into a zone which is centered on the warp from 
coordinates and is SpanX in each direction across the X axis and SpanY in each 
direction across the Y axis.

Warp NPC objects also have a name, because you can use it to refer to them later 
with 'enablenpc'/'disablenpc' 

Facing of a warp object is irrelevant, it is not used in the code and all 
current scripts have a zero in there.

** 创建NPC

<map name>,<x>,<y>,<facing>%TAB%script%TAB%<NPC Name>%TAB%<sprite id>,{<code>}
<map name>,<x>,<y>,<facing>%TAB%script%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>,{<code>}

This will place an NPC object on a specified map at the specified location, and 
is a top-level command you will use the most in your custom scripting. The NPCs 
are triggered by clicking on them, and/or by walking in their trigger area, if 
defined, see that below.

Facing is a direction the NPC sprite will face in. Not all NPC sprites have 
different images depending on the direction you look from, so for some facing 
will be meaningless. Facings are counted counterclockwise in increments of 45 
degrees, where 0 means facing towards the top of the map. (So to turn the sprite 
towards the bottom of the map, you use facing 4, and to make it look southeast 
it's facing 5.)

Sprite id is the sprite number used to display this particular NPC. For a full 
list of sprite id numbers see http://kalen.s79.xrea.com/npc/npce.shtml You may 
also use a monster's ID number instead to display a monster sprite for this NPC. 
It is possible to use a job sprite as well, but you must first define it as a 
monster sprite in 'mob_avail.txt', a full description on how to do this is not 
in the scope of this manual.
A '-1' sprite id will make the NPC invisible (and unclickable). 
A '111' sprite id will make an NPC which does not have a sprite, but is still 
clickable, which is useful if you want to make a clickable object of the 3D 
terrain.

TriggerX and triggerY, if given, will define an area, centered on NPC and 
spanning triggerX cells in every direction across X and triggerY in every 
direction across Y. Walking into that area will trigger the NPC. If no 
'OnTouch:' special label is present in the NPC code, the execution will start 
from the beginning of the script, otherwise, it will start from the 'OnTouch:' 
label. Monsters can also trigger the NPC, though the label 'OnTouchNPC:' is 
used in this case.

The code part is the script code that will execute whenever the NPC is 
triggered. It may contain commands and function calls, descriptions of which 
compose most of this document. It has to be in curly brackets, unlike elsewhere 
where we use curly brackets, these do NOT signify an optional parameter.

** 创建浮动NPC

-%TAB%script%TAB%<NPC Name>%TAB%-1,{<code>}

This will define an NPC object not triggerable by normal means. This would 
normally mean it's pointless since it can't do anything, but there are 
exceptions, mostly related to running scripts at specified time, which is what 
these floating NPC objects are for. More on that below.

** 创建商店

-%TAB%shop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%shop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>{,<itemid>:<price>...}

This will define a shop NPC, which, when triggered (which can only be done by 
clicking) will cause a shop window to come up. No code whatsoever runs in shop 
NPCs and you can't change the prices otherwise than by editing the script 
itself. (No variables even exist at this point of scripting, so don't even 
bother trying to use them.)

The item id is the number of item in the 'item_db.txt' database. If Price is set 
to -1, the 'buy price' given in the item database will be used. Otherwise, the 
price you gave will be used for this item, which is how you create differing 
prices for items in different shops.

Since trunk r12264 you can alternatively use "cashshop" in place of "shop"
to use the Cash Shop interface, allowing you to buy items with special points
(Currently stored as account vars in global_reg #CASHPOINTS and #KAFRAPOINTS.)
This type of shop will not allow you to sell items at it, you may only
purchase items here. The layout used to define sale items still count, and
"<price>" refers to how many points will be spent purchasing the them.

** 复制NPC

warp: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<spanx>,<spany>
shop/cashshop/npc: -%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>
shop/cashshop/npc: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>
npc: -%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>
npc: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>

This will duplicate an warp/shop/cashshop/NPC referred to by 'label'.
Warp duplicates inherit the target location.
Shop/cashshop duplicates inherit the item list.
NPC duplicates inherit the script code.
The rest (name, location, facing, sprite ID, span/trigger area)
is obtained from the definition of the duplicate (not inherited).

** 定义函数

function%TAB%script%TAB%<function name>%TAB%{<code>}

This will define a function object, callable with the 'callfunc' command (see 
below). This object will load on every map server separately, so you can get at 
it from anywhere. It's not possible to call the code in this object by 
anything other than the 'callfunc' script command.

The code part is the script code that will execute whenever the function is 
called with 'callfunc'. It has to be in curly brackets, unlike elsewhere where 
we use curly brackets, these do NOT signify an optional parameter.


Once an object is defined which has a 'code' field to it's definition, it 
contains script commands which can actually be triggered and executed. 

~ RID? GID? ~

What a RID is and why do you need to know
-----------------------------------------

Most scripting commands and functions will want to request data about a 
character, store variables referenced to that character, send stuff to the 
client connected to that specific character. Whenever a script is invoked by a 
character, it is passed a so-called RID - this is the character ID number of a 
character that caused the code to execute by clicking on it, walking into it's 
OnTouch zone, or otherwise.

If you are only writing common NPCs, you don't need to bother with it. However, 
if you use functions, if you use timers, if you use clock-based script 
activation, you need to be aware of all cases when a script execution can be 
triggered without a RID attached. This will make a lot of commands and functions 
unusable, since they want data from a specific character, want to send stuff to 
a specific client, want to store variables specific to that character, and they 
would not know what character to work on if there's no RID.

Unless you use 'attachrid' to explicitly attach a character to the script first.

Whenever we say 'invoking character', we mean 'the character who's RID is 
attached to the running script. The script function "playerattached" can be
used to check which is the currently attached player to the script (it will
return 0 if the there is no player attached or the attached player no longer
is logged on to the map-server).

But what about GID?
--- ---- ----- ----

GID stands for the Game ID of something, this can either be the GID obtained
through mobspawn (mob control commands) or the account ID of a character.
Another way would be to right click on a mob, 
NPC or char as GM sprited char to view the GID.

This is mostly used for the new version of skill and the mob control commmands
implemented (but NEVER documented by Lance. Shame on you...).

Item and pet scripts
--------------------

Each item in the item database has three special fields - Script , OnEquip_Script
and OnUnequip_Script. The first is script code run every time a character equips the item, 
with the RID of the equipping character. Every time they unequip an item, all 
temporary bonuses given by the script commands are cleared, and all the scripts 
are executed once again to rebuild them. This also happens in several other 
situations (like upon login) but the full list is currently unknown.

OnEquip_Script is a piece of script code run whenever the item is used by a character 
by doubleclicking on it. OnUnequip_Script runs whenever the
equipment is unequip by a character

Not all script commands work properly in the item scripts. Where commands and 
functions are known to be meant specifically for use in item scripts, they are 
described as such.

Every pet in the pet database has a PetScript field, which determines pet 
behavior. It is invoked wherever a pet of the specified type is spawned. 
(hatched from an egg, or loaded from the char server when a character who had 
that pet following them connects) This may occur in some other situations as 
well. Don't expect anything other than commands definitely marked as usable in 
pet scripts to work in there reliably.

数字
-------

Beside the common decimal numbers, which are nothing special whatsoever (though 
do not expect to use fractions, since ALL numbers are integer in this language), 
the script engine also handles hexadecimal numbers, which are otherwise 
identical. Writing a number like '0x<hex digits>' will make it recognized as a 
hexadecimal value. Notice that 0x10 is equal to 16. Also notice that if you try 
to 'mes 0x10' it will print '16'.

This is not used much, but it pays to know about it.

变量
---------

The meat of every programming language is variables - places where you store 
data. 

Variables are divided into and uniquely identified by the combination of:
prefix  - determines the scope and extent (or lifetime) of the variable
name    - an identifier consisting of '_' and alphanumeric characters
postfix - determines the type of the variable: integer or string

Scope can be:
global    - global to all servers
local     - local to the server
account   - attached to the account of the character identified by RID
character - attached to the character identified by RID
npc       - attached to the NPC
scope     - attached to the scope of the instance

Extent can be:
permanent - They still exist when the server resets.
temporary - They cease to exist when the server resets.

Prefix: scope and extent
nothing  - A permanent variable attached to the character, the default variable
           type. They are stored with all the account data in "save\athena.txt"
           in TXT versions and in the SQL versions in the `global_reg_value`
           table using type 3.
"@"      - A temporary variable attached to the character.
           SVN versions before 2094 revision and RC5 version will also treat
           'l' as a temporary variable prefix, so beware of having variable
           names starting with 'l' if you want full backward compatibility.
"$"      - A global permanent variable.
           They are stored in "save\mapreg.txt" or database table `mapreg`,
           depending on server type.
"$@"     - A global temporary variable.
           This is important for scripts which are called with no RID
           attached, that is, not triggered by a specific character object.
"."      - A NPC variable.
           They exist in the NPC and disappear when the server restarts or the 
           NPC is reloaded. Can be accessed from inside the NPC or by calling 
           'getvariableofnpc'.
".@"     - A scope variable.
           They are unique to the instance and scope. Each instance has it's 
           own scope that ends when the script ends. Calling a function with 
           callsub/callfunc starts a new scope, returning from the function 
           ends it. When a scope ends, it's variables are converted to values 
           ('return .@var;' returns a value, not a reference).
"#"      - A permanent local account variable.
           They are stored with all the account data in "save\accreg.txt" in
           TXT versions and in the SQL versions in the 'global_reg_value'
           table using type 2.
"##"     - A permanent global account variable stored by the login server.
           They are stored in "save\account.txt" and in the SQL versions in the
           'global_reg_value' table, using type 1. The only difference you will
           note from normal # variables is when you have multiple char-servers
           connected to the same login server. The # variables are unique to
           each char-server, while the ## variables are shared by all these
           char-servers.

Postfix: integer or string
nothing - integer variable, can store positive and negative numbers, but only 
          whole numbers (so don't expect to do any fractional math)
'$'     - string variable, can store text

Examples:
  name  - permanent character integer variable
  name$ - permanent character string variable
 @name  - temporary character integer variable
 @name$ - temporary character string variable
 $name  - permanent global integer variable
 $name$ - permanent global string variable
$@name  - temporary global integer variable
$@name$ - temporary global string variable
 .name  - NPC integer variable
 .name$ - NPC string variable
.@name  - scope integer variable
.@name$ - scope string variable
 #name  - permanent local account integer variable
 #name$ - permanent local account string variable
##name  - permanent global account integer variable
##name$ - permanent global account string variable

If a variable was never set, it is considered to equal zero for integer 
variables or an empty string ("", nothing between the quotes) for string 
variables. Once you set it to that, the variable is as good as forgotten 
forever, and no trace remains of it even if it was stored with character or 
account data.

Some variables are special, that is, they are already defined for you by the 
scripting engine. You can see the full list somewhere in 'db/const.txt', which 
is a file you should read, since it also allows you to replace lots of numbered 
arguments for many commands with easier to read text. The special variables most 
commonly used are all permanent character-based variables:

StatusPoint - Amount of status points remaining.
BaseLevel   - Current base level
SkillPoint  - Amount of skill points remaining
Class       - Current job
Upper       - 1 if the character is an advanced job class.
Zeny        - Current amount of Zeny
Sex         - Character's gender, 0 if female, 1 if male.
Weight      - The weight the character currently carries.
MaxWeight   - The maximum weight the character can carry.
JobLevel    - Character's job level
BaseExp     - The amount of base experience points the character has.
              Notice that it's zero (or close) if the character just got a level.
JobExp      - Same for job levels
NextBaseExp - Amount of experience points needed to reach the next base level.
NextJobExp  - Same for job levels.
Hp          - Current amount of hit points.
MaxHp       - Maximum amount of hit points.
Sp          - Current spell points.
MaxSp       - Maximum amount of spell points.
BaseJob     - This is sneaky, apparently meant for baby class support.
              This will supposedly equal Job_Acolyte regardless of whether the 
              character is an acolyte or a baby acolyte, for example.
Karma       - The character's karma. Karma system is not fully functional, but 
              this doesn't mean this doesn't work at all. Not tested.
Manner      - The character's manner rating. Becomes negative if the player 
              utters words forbidden through the use of 'manner.txt' client-side 
              file.

While these behave as variables, do not always expect to just set them - it is 
not certain whether this will work for all of them. Whenever there is a command 
or a function to set something, it's usually preferable to use that instead. The 
notable exception is Zeny, which you can and often will address directly -
setting it will make the character own this number of Zeny.
If you try to set Zeny to a negative number, the script will be terminated with an error.

字符串
-------

To include symbol '"' in a string you should use prefix '\"'


数组
------

Arrays (in eAthena at least) are essentially a set of variables going under the 
same name. You can tell between the specific variables of an array with an 
'array index', a number of a variable in that array:

<variable name>[<array index>]

Variables stored in this way, inside an array, are also called 'array elements'. 
Arrays are specifically useful for storing a set of similar data (like several 
item IDs for example) and then looping through it. You can address any array 
variable as if it was a normal variable:

    set @arrayofnumbers[0],1;

You can also do sneaky things like using a variable (or an expression, or even a 
value from an another array) to get at an array value:

    set @x,100;
    set @arrayofnumbers[@x],10;
    
This will make @arrayofnumbers[100] equal to 10.

Notice that index numbering always starts with 0. Arrays cannot hold more than 
128 variables. (So the last one can't have a number higher than 127)

And array indexes probably can't be negative. Nobody tested what happens when 
you try to get a negatively numbered variable from an array, but it's not going 
to be pretty. :)

Arrays can naturally store strings:

@menulines$[0] is the 0th element of the @menulines$ array of strings. Notice 
the '$', normally denoting a string variable, before the square brackets that 
denotes an array index.

Resume of the allowed variable and array scopes
------ -- --- ------- -------- --- ----- ------

+==========+======+=======+
|VarType   | Norm | Array |
+==========+======+=======+
|$Str$     | OK!  | OK!   |
+----------+------+-------+
|$@Str$    | OK!  | OK!   |
+----------+------+-------+
|@Str$     | OK!  | OK!   |
+----------+------+-------+
|#Str$     | OK!  | FAIL! |
+----------+------+-------+
|Str$      | OK!  | FAIL! |
+----------+------+-------+
|$Int      | OK!  | OK!   |
+----------+------+-------+
|$@Int     | OK!  | OK!   |
+----------+------+-------+
|@Int      | OK!  | OK!   |
+----------+------+-------+
|#Int      | OK!  | FAIL! |
+----------+------+-------+
|Int       | OK!  | FAIL! |
+----------+------+-------+
|.Str$     | OK!  | OK!   |
+----------+------+-------+
|.Int      | OK!  | OK!   |
+----------+------+-------+
|.@Str$    | OK!  | OK!   |
+----------+------+-------+
|.@Int     | OK!  | OK!   |
+----------+------+-------+

操作符
---------

Operators are things you can do to variables and numbers. They are either the 
common mathematical operations or conditional operators

+ - will add two numbers. If you try to add two strings, the result will be a 
    string glued together at the +. You can add a number to a string, and the
    result will be a string. No other math operators work with strings.
- - will subtract two numbers. 
* - will multiply two numbers.
/ - will divide two numbers. Note that this is an integer division, i.e.
    7/2 is not equal 3.5, it's equal 3.
% - will give you the remainder of the division. 7%2 is equal to 1.

There are also conditional operators. This has to do with the conditional 
command 'if' and they are meant to return either 1 if the condition is satisfied 
and 0 if it isn't. (That's what they call 'boolean' variables. 0 means 'False'. 
Anything except the zero is 'True' Odd as it is, -1 and -5 and anything below 
zero will also be True.)

You can compare numbers to each other and you compare strings to each other, but 
you can not compare numbers to strings.

 ==  - Is true if both sides are equal. For strings, it means they are the same.
 >=  - True if the first value is equal to, or greater than, the second value.
 <=  - True if the first value is equal to, or less than, the second value
 >   - True if the first value greater than the second value
 <   - True if the first value is less than the second value
 !=  - True if the first value IS NOT equal to the second one

Examples:

 1==1 is True.
 1<2 is True while 1>2 is False.
 @x>2 is True if @x is equal to 3. But it isn't true if @x is 2.

Only '==' and '!=' have been tested for comparing strings. Since there's no way 
to code a seriously complex data structure in this language, trying to sort 
strings by alphabet would be pointless anyway.

Comparisons can be stacked in the same condition:

 && - Is True if and only if BOTH sides are true.
      ('1==1 && 2==2' is true. '2==1 && 1==1' is false.)
 || - Is True if either side of this expression is True.

 1==1 && 2==2 is True.
 1==1 && 2==1 is False.
 1==1 || 2==1 is True.

Logical bitwise operators work only on numbers, and they are the following:

 << - Left shift.
 >> - Right shift.
	Left shift moves the binary 1(s) of a number n positions to the left,
	which is the same as multiplying by 2, n times.
	In the other hand, Right shift moves the binary 1(s) of a number n positions
	to the right, which is the same as dividing by 2, n times.
		Example:
		set b,2;
		set a, b << 3;
		mes a;
		set a, a >> 2;
		mes a;
	The first mes command would display 16, which is the same as 2 x (2 x 2 x 2) = 16.
	The second mes command would display 4, which is the same as 16 / 2 = 8. 8 / 2 = 4.
 &  - And.
 |  - Or.
	The bitwise operator AND (&) is used to test two values against each other, 
	and results in setting bits which are active in both arguments. This can
	be used for a few things, but in eAthena this operator is usually used to
	create bit-masks in scripts. 
	
	The bitwise operator OR (|)sets to 1 a binary position if the binary position
	of one of the numbers is 1. This way a variable can hold several values we can check,
	known as bit-mask. A variable currently can hold up to 32 bit-masks (from position 0
	to position 1). This is a cheap(skate) and easy way to avoid using arrays to store several checks
	that a player can have.
	
	A bit-mask basically is (ab)using the variables bits to set various options in 
	one variable. With the current limit if variables it is possible to store 32 
	different options in one variable (by using the bits on position 0 to 31).

	Example(s):
	- Basic example of the & operator, bit example:
		10 & 2 = 2
	Why? :
		10 = 2^1 + 2^3 (2 + 8), so in bits, it would be 1010
		2 = 2^1 (2), so in bits (same size) it would be 0010
		The & (AND) operator sets bits which are active (1) in both arguments, so in the
		example 1010 & 0010, only the 2^1 bit is active (1) in both. Resulting in the bit
		0010, which is 2.
	- Basic example of creating and using a bit-mask:
		set @options,2|4|16; //(note: this is the same as 2+4+16, or 22)
		if (@options & 1)	mes "Option 1 is activated";
		if (@options & 2) mes "Option 2 is activated";
		if (@options & 4) mes "Option 3 is activated";
		if (@options & 8) mes "Option 4 is activated";
		if (@options & 16) mes "Options 5 is activated";
	This would return the messages about option 2, 3 and 5 being shown (since we've set
	the 2,4 and 16 bit to 1).
 ^  - Xor.
	The bitwise operator XOR (eXclusive OR) sets a binary position to 0 if both 
	numbers have the same value in the said position. On the other hand, it 
	sets to 1 if they have different values in the said binary position.
	This is another way of setting and unsetting bits in bit-masks.
	
	Example:
	- First let's set the quests that are currently in progress:
		set inProgress,1|8|16; // quest 1,8 and 16 are in progress
	- After playing for a bit, the player starts another quest:
		if( inProgress&2 == 0 ){
			// this will set the bit for quest 2 (inProgress has that bit set to 0)
			set inProgress,inProgress^2;
			mes "Quest 2: find a newbie and be helpful to him for an hour.";
			close;
		}
	- After spending some time reading info on Xor's, the player finally completes quest 1:
		if( inProgress&1 && isComplete ){
			// this will unset the bit for quest 1 (inProgress has that bit set to 1)
			set inProgress,inProgress^1;
			mes "Quest 1 complete!! You unlocked the secrets of the Xor dynasty, use them wisely.";
			close;
		}

Unary operators with only with a single number, which follows the operator, and
are following:

 -  - Negation.
	The sign of the number will be reversed. If the number was positive, it will
	become negative and vice versa.

	Example:
		set .@myvar,10;
		mes "Negative 10 is "+(-.@myvar);

 !  - Logical Not.
	Reverses the boolean result of an expression. True will become false and
	false will become true.

	Example:
		if(!callfunc("F_dosomething"))
		{
			mes "Doing something failed.";
			close;
		}

 ~  - Bitwise Not.
	Reverses each bit in a number, also known as one's complement. Cleared bits
	are set, and set bits are cleared.

	Example:
	- Ensure, that quest 2 is disabled, while keeping all other active, if they are.
		set inProgress,inProgress&(~2);  // same as set inProgress,inProgress&0xfffffffd

Ternary operators take three expressions (numbers, strings or boolean), and are
following:

 ?: - Conditional operator
	Very useful e.g. to replace

		if(Sex) mes "..."; else mes "...";

	clauses with simple

		mes "Welcome, " + (Sex?"Mr.":"Mrs.") + " " + strcharinfo(0);

	or to replace any other simple if-else clauses. It might be worth
	mentioning that ?: has low priority and has to be enclosed with
	parenthesis in most (if not all) cases.


=====================
|1.- Basic commands.|
=====================
---------------------------------------

*mes <内容>;
	作用：	把<内容>的内容显示到消息窗口中。 

---------------------------------------

*next;
	作用：	在消息窗口上显示next按钮并等待。 

---------------------------------------

*close;
	作用：	在消息窗口上显示close按钮并结束脚本。 

---------------------------------------

*close2;
	作用：	在消息窗口上显示close按钮，但不结束脚本。要结束脚本时请使用end命令。 

---------------------------------------

*end;
	作用：	结束脚本

---------------------------------------

*set <变量名>,<要设置的值>;

	作用：	把值传入<变量。值为字符串类型时，不要忘记变量名的$后缀。 

---------------------------------------

*setd <变量名>,<要设置的值>;

	作用：设置一个变量的值（主要作用是可以动态改变变量名）
	举例:
		set $var$, "Poring";

		setd "$var$", "Poporing";
		mes $var$; // Will return Poporing

		setd "$" + $var$ + "123$", "Poporing is cool";
		mes $Poporing123$; // Will return Poporing is cool.

---------------------------------------

*getd("<变量名>")

	作用：返回一个变量的引用（主要作用是可以动态改变变量名）
	举例:
		set getd("$varRefence"), 1;
		set @i, getd("$pikachu");

---------------------------------------

*getvariableofnpc(<变量>,"<NPC名字>")
	作用：返回指定NPC的变量
	举例:
	//设置.v变量的值为NPC：TargetNPC的变量.var
		set .v,getvariableofnpc(.var,"TargetNPC");
	
	//设置NPC：TargetNPC的变量.var的值为1
		set getvariableofnpc(.var,"TargetNPC"),1;

---------------------------------------

*goto <label>;

This command will make the script jump to a label, usually used in conjunction 
with other command, such as "if", but often used on it's own.

	...
	goto Label;
	mes "This will not be seen";
Label:
	mes "This will be seen";

Note by FlavioJS: goto's are "evil" and should be avoided if possible

---------------------------------------

*menu "<option_text>",<target_label>{,"<option_text>",<target_label>,...};

This command will create a selectable menu for the invoking character. Only one 
menu can be on screen at the same time.

Depending on what the player picks from the menu, the script execution will 
continue from the corresponding label. (it's string-label pairs, not label-
string)

Options can be grouped together, separated by the character ':'.

	menu "A:B",L_Wrong,"C",L_Right;

It also sets a special temporary character variable @menu, which contains the 
number of option the player picked. (Numbering of options starts at 1.)
This number is consistent with empty options and grouped options.

       menu "A::B",L_Wrong,"",L_Impossible,"C",L_Right;
    L_Wrong:
       // If they click "A" or "B" they will end up here
	   // @menu == 1 if "A"
	   // @menu == 2 will never happen because the option is empty
	   // @menu == 3 if "B"
	L_Impossible:
	   // Empty options are not displayed and therefore can't be selected
	   // this label will never be reached from the menu command
    L_Right:
       // If they click "C" they will end up here
	   // @menu == 5

If a label is '-', the script execution will continue right after the menu 
command if that option is selected, this can be used to save you time, and 
optimize big scripts.

        menu "A::B:",-,"C",L_Right;
        // If they click "A" or "B" they will end up here
		// @menu == 1 if "A"
		// @menu == 3 if "B"
    L_Right:
        // If they click "C" they will end up here
		// @menu == 5

Both these examples will perform the exact same task.

If you give an empty string as a menu item, the item will not display. This
can effectively be used to script dynamic menus by using empty string for
entries that should be unavailable at that time.

You can do it by using arrays, but watch carefully - this trick isn't high 
wizardry, but minor magic at least. You can't expect to easily duplicate it 
until you understand how it works.

Create a temporary array of strings to contain your menu items, and populate it 
with the strings that should go into the menu at this execution, making sure not 
to leave any gaps. Normally, you do it with a loop and an extra counter, like 
this:

	setarray @possiblemenuitems$[0],<list of potential menu items>;
	set @j,0; // That's the menu lines counter.
	
	// We loop through the list of possible menu items.
	// @i is our loop counter.
	for( set @i,0; @i<getarraysize(@possiblemenuitems$) ; set @i,@i+1 )
	{
		// That 'condition' is whatever condition that determines whether 
		// a menu item number @i actually goes into the menu or not.
		
		if (<condition>)
		{
			// We record the option into the list of options actually available.
			
			set @menulist$[@j],@possiblemenuitems$[@i];
			
			// We just copied the string, we do need it's number for later 
			// though, so we record it as well.
			
			set @menureference[@j],@i;
			
			// Since we've just added a menu item into the list, we increment 
			// the menu lines counter.
			
			set @j,@j+1;
		}
		
		// We go on to the next possible menu item.
	}

This will create you an array @menulist$ which contains the text of all items 
that should actually go into the menu based on your condition, and an array 
@menureference, which contains their numbers in the list of possible menu items. 
(Remember, arrays start with 0.) There's less of them than the possible menu 
items you've defined, but the menu command can handle the empty lines - only if 
they are last in the list, and if it's made this way, they are. Now comes a 
dirty trick:

	// X is whatever the most menu items you expect to handle.
	menu @menulist$[0],-,@menulist$[1],-,....@menulist$[<X>],-;

This calls up a menu of all your items. Since you didn't copy some of the 
possible menu items into the list, it's end is empty and so no menu items will 
show up past the end. But this menu call doesn't jump anywhere, it just 
continues execution right after the menu command. (And it's a good thing it 
doesn't, cause you can only explicitly define labels to jump to, and how do you 
know which ones to define if you don't know beforehand which options will end up 
where in your menu?)
But how do you figure out which option the user picked? Enter the @menu.

@menu contains the number of option that the user selected from the list, 
starting with 1 for the first option. You know now which option the user picked 
and which number in your real list of possible menu items it translated to:

    mes "You selected "+@possiblemenuitems$[@menureference[@menu-1]]+"!";

@menu is the number of option the user picked.
@menu-1 is the array index for the list of actually used menu items that we 
made.
@menureference[@menu-1] is the number of the item in the array of possible menu 
items that we've saved just for this purpose.

And @possiblemenuitems$[@menureference[@menu-1]] is the string that we used to 
display the menu line the user picked. (Yes, it's a handful, but it works.)

You can set up a bunch of 'if (@menureference[@menu-1]==X) goto Y' statements to 
route your execution based on the line selected and still generate a different 
menu every time, which is handy when you want to, for example, make users select 
items in any specific order before proceeding, or make a randomly shuffled menu.

Kafra code bundled with the standard distribution uses a similar array-based 
menu technique for teleport lists, but it's much simpler and doesn't use @menu, 
probably since that wasn't documented anywhere.

See also 'select', which is probably better in this particular case. Instead of 
menu, you could use 'select' like this:

    set @dummy,select(@menulist$[0],@menulist$[1],....@menulist$[<X>]);
    
For the purposes of the technique described above these two statements are 
perfectly equivalent.

---------------------------------------

*select("<option>"{,"<option>",...})
*prompt("<option>"{,"<option>",...})

This function is a handy replacement for 'menu' for some specific cases where 
you don't want a complex label structure - like, for example, asking simple yes-
no questions. It will return the number of menu option picked, starting with 1. 
Like 'menu', it will also set the variable @menu to contain the option the user 
picked.

    if (select("Yes:No")==1) mes "You said yes, I know.";

And like 'menu', the selected option is consistent with grouped options 
and empty options.

prompt works almost the same as select, except that when a character clicks
the Cancel button, this function will return 255 instead.

---------------------------------------

*input(<variable>{,<min>{,<max>}})

This command will make an input box pop up on the client connected to the 
invoking character, to allow entering of a number or a string. This has many 
uses, one example would be a guessing game, also making use of the 'rand' 
function:

	mes "[Woman]";
	mes "Try and guess the number I am thinking of.";
	mes "The number will be between 1 and 10.";
	next;
	set @number, rand(1,10);
	input @guess;
	if(@guess==@number)
	{
		mes "[Woman]";
		mes "Well done that was the number I was thinking of";
		close;
	}
	else
	{
		mes "[Woman]";
		mes "Sorry, that wasn't the number I was thinking of.";
		close;
	}

If you give the input command a string variable to put the input in, it will 
allow the player to enter text. Otherwise, only numbers will be allowed.

	mes "[Woman]";
	mes "Please say HELLO";
	next;
	input @var$;
	if(@var$=="HELLO")
	{
		mes "[Woman]";
		mes "Well done you typed it correctly";
		close;
	}
	else
	{
		mes "[Woman]";
		mes "Sorry you got it wrong";
		close;
	}

Normally you may not input a negative number with this command.
This is done to prevent exploits in badly written scripts, which would 
let people, for example, put negative amounts of zeny into a bank script and 
receive free zeny as a result.

Since trunk r12192 the command has two optional arguments and a return value.
The default value of 'min' and 'max' can be set with 'input_min_value' and 
'input_max_value' in script_athena.conf.
For numeric inputs the value is capped to the range [min,max]. Returns 1 if 
the value was higher than 'max', -1 if lower than 'min' and 0 otherwise.
For string inputs it returns 1 if the string was longer than 'max', -1 is 
shorter than 'min' and 0 otherwise.

---------------------------------------

*callfunc "<function>"{,<argument>,...<argument>};
*callfunc("<function>"{,<argument>,...<argument>})

This command lets you call up a function NPC. A function NPC can be called from 
any script on any map server. Using the 'return' command it will come back to 
the place that called it.

	place,50,50,6%TAB%script%TAB%Woman%TAB%115,{
		mes "[Woman]"
		mes "Lets see if you win";
		callfunc "funcNPC";
		mes "Well done you have won";
		close;
	}
	function%TAB%script%TAB%funcNPC%TAB%{
		set @win, rand(2);
		if(@win==0) return;
		mes "Sorry you lost";
		end;
	}

You can pass arguments to your function - values telling it what exactly to do -
which will be available there with getarg() (see 'getarg')
Notice that returning is not mandatory, you can end execution right there.

If you want to return a real value from inside your function NPC, it is better 
to write it in the function form, which will also work and will make the script 
generally cleaner:

	place,50,50,6%TAB%script%TAB%Man%TAB%115,{
		mes "[Man]"
		mes "Gimme a number!";
		next;
		input @number;
		if (callfunc("OddFunc",@number)) mes "It's Odd!";
		close;
	}
	function%TAB%script%TAB%OddFunc%TAB%{
		if (getarg(0)%2==0) return 0;// it's even
		return 1;// it's odd
	}

---------------------------------------

*callsub <label>{,<argument>,...<argument>};

This command will go to a specified label within the current script (do NOT use 
quotes around it) coming in as if it were a 'callfunc' call, and pass it 
arguments given, if any, which can be recovered there with 'getarg'. When done 
there, you should use the 'return' command to go back to the point from where 
this label was called. This is used when there is a specific thing the script 
will do over and over, this lets you use the same bit of code as many times as 
you like, to save space and time, without creating extra NPC objects which are 
needed with 'callfunc'. A label is not callable in this manner from another 
script.

		mes "[Woman]"
		mes "Lets see if you win";
		callsub Check;
		mes "Well done you have won";
		close;
	Check:
		set @win, rand(2);
		if(@win==0) return;
		mes "Sorry you lost";
		close;

---------------------------------------

*getarg(<index>{,<default_value>})

This function is used when you use the 'callsub' or 'callfunc' commands. In the 
call you can specify variables that will make that call different from another 
one. This function will return an argument the function or subroutine was 
called with, and is the normal way to get them. 
This is another thing that can let you use the same code more than once. 

Argument numbering starts with 0, i.e. the first argument you gave is number 0. 
If no such argument was given, a zero is returned.

	place,50,50,6%TAB%script%TAB%Woman1%TAB%115,{
		mes "[Woman]";
		mes "Lets see if you win";
		callfunc "funcNPC",2;
		mes "Well done you have won";

	...

	place,52,50,6%TAB%script%TAB%Woman2%TAB%115,{
		mes "[Woman]";
		mes "Lets see if you win";
		callfunc "funcNPC",5;
		mes "Well done you have won";

	...

	function%TAB%script%TAB%funcNPC%TAB%{
		set @win, rand(getarg(0));
		if(@win==0) return;
		mes "Sorry you lost";

"woman1" NPC object calls the funcNPC. The argument it gives in this call is 
stated as 2, so when the random number is generated by the 'rand' function, it 
can only be 0 or 1. Whereas "woman2" gives 5 as the argument number 0 when 
calling the function, so the random number could be 0, 1, 2, 3 or 4, this makes 
"woman2" less likely to say the player won. 

You can pass multiple arguments in a function call:

	callfunc "funcNPC",5,4,3;

getarg(0) would be 5, getarg(1) would be 4 and getarg(2) would be 3.

Getarg has an optional argument since trunk r10773 and stable r10958.
If the target argument exists, it is returned.
Otherwise, if <default_value> is present it is returned instead, 
if not the script terminates immediately.

in the previous example getarg(2,-1) would be 3 and getarg(3,-1) would be -1

---------------------------------------

*return {<value>};

When you use callsub or callfunc, this command allows you to go back to the 
calling script. You can optionally return with a value telling the calling 
program what exactly happened.

	callfunc "<your function>";// when nothing is returned
	set <variable>,callfunc("<your function>");// when a value is being returned

---------------------------------------

*function <function name>;
*<function name>;
*function <function name> {
<code>
}

(Skotlex stop being so selfish and give us all the commands T~T! J/k lol :P)

This works like callfunc, but doesn't support arguments like callfunc. It's used for cleaner
and fast script that doesn't require arguments for it to work. Also they must be inside a script. 
They're not separated scripts and they work more like labels.

Note it looks like the normal declaration

Usage:

You first Declare the function with function <function name>;.

Put the rest of your code. You can use then <function name>; to call the function. If it returns a value is unsure,
test it if you want and give us some comments ;3

And at least, but inside the script itself, put the function <function name> {<code>}.

举例:

prontera,154,189,4	script	Item seller	767,{

function SF_Selling;

mes "I'll open this now if you have more than 50z and you are level 50 or bigger";
next;

if (Zeny > 50) && (BaseLevel > 50) {
	mes "Welcome";
	next;
	SF_Selling;
	close;
} else

set @needed,50-BaseLevel;
mes "You either are Level "+BaseLevel+", thus you need "+@needed+" more levels";
mes "to be able to use this npc; or you don't have enough zeny, so get some please";
close;

function SF_Selling {

	mes "Would you like to buy a phracon for 50z?";
	switch(select("Yes","No, thanks")) {

	case 1:
		mes "Ok, how many?";
		input @quantity;
		set @check,Zeny/50;
		if (@quantity > @check) {
			mes "Sorry but you can only have "+@check+" Phracons with "+Zeny;
			close;
		} else
		next;
		mes "here you have";
		set Zeny,Zeny-@quantity*50;
		getitem 1010,@quantity;
		close;
	case 2:
		mes "Good bye then";
		close;
		}
	}
	return;
}

---------------------------------------

*if (<condition>) <statement>;

This is the basic conditional statement command, and just about the only one 
available in this scripting language. 

The condition can be any expression. All expressions resulting in a non-zero 
value will be considered True, including negative values. All expressions 
resulting in a zero are false.

If the expression results in True, the statement will be executed. If it isn't 
true, nothing happens and we move on to the next line of the script.

    if (1)  mes "This will always print.";
    if (0)  mes "And this will never print.";
    if (5)  mes "This will also always print.";
    if (-1) mes "Funny as it is, this will also print just fine.";

For more information on conditional operators see the operators section above.
Anything that is returned by a function can be used in a condition check without 
bothering to store it in a specific variable:

    if (strcharinfo(0)=="Daniel Jackson") mes "It is true, you are Daniel!";

More examples of using the 'if' command in the real world:

Example 1:

        set @var1,1;
        input @var2;
        if(@var1==@var2) goto L_Same;
        mes "Sorry that is wrong";
        close;
    L_Same:
        close;

Example 2:
    
    set @var1,1;
    input @var2;
    if(@var1!=@var2) mes "Sorry that is wrong";
    close;

(Notice examples 1 and 2 have the same effect.)

Example 3:

    set @var1,@var1+1;
    mes "[Forgetfull Man]";
    if (@var==1) mes "This is the first time you have talked to me";
    if (@var==2) mes "This is the second time you have talked to me";
    if (@var==3) mes "This is the third time you have talked to me";
    if (@var==4) mes "This is the forth time you have talked to me, but I think I am getting amnesia, I have forgoten about you";
    if (@var==4) set @var,0;
    close;

Example 4:

        mes "[Quest Person]";
        if(countitem(512)>=1) goto L_GiveApple;
        // The number 512 was found from item_db, it is the item number for the Apple.
        mes "Can you please bring me an apple?";
        close;
    L_GiveApple:
        mes "Oh an apple, I didnt want it, I just wanted to see one";
        close;

Example 5:

        mes "[Person Checker]";
        if($name$!=null) goto L_Check;
        mes "Please tell me someones name";
        next;
        input $name$;
        set $name2$,strcharinfo(0);
        mes "[Person Checker]";
        mes "Thank you";
    L_Check:
        if($name$==strcharinfo(0) ) goto L_SameName;
        mes "[Person Checker]";
        mes "You are not the person that " +$name2$+ " mentioned";
    L_End:
        set $name$,null;
        set $name2$,null;
        close;
    L_SameName:
        mes "[Person Checker]";
        mes "You are the person that " +$name2$+ " just mentioned";
        mes "nice to meet you";
        goto L_End;

See 'strcharinfo' for explanation of what this function does.

Example 6: Using complex conditions.

        mes "[Multi Checker]";
        if( (@queststarted==1) && (countitem(512)>=5) ) goto L_MultiCheck;
        // Only if the quest has been started AND You have 5 apples will it goto "L_MultiCheck"
        mes "Please get me 5 apples";
        set @queststarted,1;
        close;
    L_MultiCheck:
        mes "[Multi Checker]";
        mes "Well done you have started the quest of got me 5 apples";
        mes "Thank you";
        set @queststarted,0;
        delitem 512,5;
        close;

With the Advanced scripting engine, we got nested if's. That is:

if (<condition>)
	dothis;
else
	dothat;
	
If the condition doesn't meet, it'll do the action following the else.
We can also group several actions depending on a condition, the following way:

if (<condition)
{
	dothis1;
	dothis2;
	dothis3;
} else {
	dothat1;
	dothat2;
	dothat3;
	dothat4;
}

Remember that if you plan to do several actions upon the condition being false, and 
you forget to use the curlies (the { } ), the second action will be executed regardless
the output of the condition, unless of course, you stop the execution of the script if the
condition is true (that is, in the first grouping using a return; , and end; or a close; )

Also, you can have multiple conditions nested or chained, and don't worry about limits as to
how many nested if you can have, there is no spoon ;)

...
if (<condition 1>)
	dothis;
else if (<condition 2>)
{
	dotheother;
	do that;
	end;
} else
	do this;
...

---------------------------------------

*jump_zero (<condition>),<label>;

This command works kinda like an 'if'+'goto' combination in one go. (See 'if'). 
If the condition is false (equal to zero) this command will immediately jump to 
the specified label like in 'goto'.

While 'if' is more generally useful, for some cases this could be an 
optimisation.

---------------------------------------
*while (<condition>) <statement>;

This is probably the simplest and most frequently used loop structure. The 'while' 
statement can be interpreted as "while <condition> is true, perform <statement>". 
It is a pretest loop, meaning the conditional expression is tested before any of the 
statements in the body of the loop are performed. If the condition evaluates to 
false, the statement(s) in the body of the loop is/are never executed. If the 
condition evaluates to true, the statement(s) are executed, then control transfers 
back to the conditional expression, which is reevaluated and the cycle continues. 

Multiple statements can be grouped with { }, curly braces, just like with the 'if' statement.

Example 1:
	while (switch(select("Yes:No") == 2 ))
		mes "You picked no.";

Example 2: multiple statements
	while (switch(select("Yes:No") == 2 )) {
		mes "Why did you pick no?";
		mes "You should pick yes instead!";
	}

Example 3: counter-controlled loop
	set .@i, 1;
	while (.@i <= 5) {
		mes "This line will print 5 times.";
		set .@i, .@i +1;
	}

Example 4: sentinel-controlled loop
	mes "Input 0 to stop";
	input .@num;
	while (.@num != 0) {
		mes "You entered " + .@num;
		input .@num;
	}
	close;

---------------------------------------

*for (<variable initialization>; <condition>; <variable update>) <statement>;

Another pretest looping structure is the 'for' statement. It is considered a 
specialized form of the 'while' statement, and is usually associated with counter-
controlled loops. Here are the steps of the 'for' statement: the initialize 
statement is executed first and only once. The condition test is performed. 
When the condition evaluates to false, the rest of the for statement is skipped. 
When the condition evaluates to true, the body of the loop is executed, then the 
update statement is executed (this usually involves incrementing a variable). 
Then the condition is reevaluated and the cycle continues. 

Example 1:
	for( set .@i, 1; .@i <= 5; set .@i, .@i +1 )
		mes "This line will print 5 times.";

Example 2:
	mes "This will print the numbers 1 - 5.";
	for( set .@i, 1; .@i <= 5; set .@i, .@i +1 )
		mes .@i;

---------------------------------------

*do { <statement>; } while (<condition>);

The 'do...while' is the only posttest loop structure available in this script 
language. With a posttest, the statements are executed once before the condition 
is tested. When the condition is true, the statement(s) are repeated. When the 
condition is false, control is transferred to the statement following the 
'do...while' loop expression.

Example 1: sentinel-controlled loop
	mes "This menu will keep appearing until you pick Cancel";
	do {
		set .@menu, select("One:Two:Three:Cancel");
	} while (.@menu != 4);

Example 2: counter-controlled loop
	mes "This will countdown from 10 to 1.";
	set .@i, 10;
	do {
		mes .@i;
		set .@i, .@i - 1;
	} while (.@i > 0);

---------------------------------------

*setarray <array name>[<first value>],<value>{,<value>...<value>};

This command will allow you to quickly fill up an array in one go. Check the 
Kafra scripts in the distribution to see this used a lot.

    setarray @array[0], 100, 200, 300, 400, 500, 600;

First value is the index of the first element of the array to alter. For 
举例:

    setarray @array[0],200,200,200;
    setarray @array[1],300,150;
    
will produce:

 @array[0]=200
 @array[1]=300
 @array[2]=150

---------------------------------------

*cleararray <array name>[<first value to alter>],<value>,<number of values to set>;

This command will change many array values at the same time to the same value.

    setarray @array[0], 100, 200, 300, 400, 500, 600;
    // This will make all 6 values 0
    cleararray @array[0],0,6;
    // This will make array element 0 change to 245
    cleararray @array[0],245,1;
    // This will make elements 1 and 2 change to 345
    cleararray @array[1],345,2;

See 'setarray'.

---------------------------------------

*copyarray <destination array>[<first value>],<source array>[<first value>],<amount of data to copy>;

This command lets you quickly shuffle a lot of data between arrays, which is in 
some cases invaluable.

    setarray @array[0], 100, 200, 300, 400, 500, 600;
    // So we have made @array[]
    copyarray @array2[0],@array[2],2;
    
    // Now, @array2[0] will be equal to @array[2] (300) and 
    // @array2[1] will be equal to @array[3].

So using the examples above:
 @array[0]  = 100
 @array[1]  = 200
 @array[2]  = 300
 @array[3]  = 400
 @array[4]  = 500
 @array[5]  = 600
 
New Array:
 @array2[0] = 300
 @array2[1] = 400
 @array2[2] = 0
 @array2[3] = 0

Notice that @array[4] and @array[5] won't be copied to the second array, and it will return a 
0.

---------------------------------------

*deletearray <array name>[<first value>],<how much to delete>

This command will delete a specified number of array elements totally from an 
array, shifting all the elements beyond this towards the beginning.

    // This will delete array element 0, and move all the other array elements 
    // up one place.
    deletearray @array[0],1

// This would delete array elements numbered 1, 2 and 3, leave element 0 in its 
// place, and move the other elements ups, so there are no gaps.

    deletearray @array[1],3

---------------------------------------

======================================
|2.- Information-retrieving commands.|
======================================
---------------------------------------

*strcharinfo(<类型>)

This function will return either the name, party name or guild name for the 
invoking character. Whatever it returns is determined by type.

 0 - Character's name.
 1 - The name of the party they're in if any.
 2 - The name of the guild they're in if any.
 3 - 读取关联角色的帐号注册email地址.
 4 - 读取关联角色的帐号当前IP地址.

If a character is not a member of any party or guild, an empty string will be 
returned when requesting that information.

---------------------------------------

---------------------------------------

*strnpcinfo(<类型>)

This function will return the various parts of the name of the calling npc.
Whatever it returns is determined by type.

 0 - The NPC's display name (visible#hidden)
 1 - The visible part of the NPC's display name
 2 - The hidden part of the NPC's display name
 3 - The NPC's unique name (::name)

---------------------------------------

*getarraysize(<array name>)

This function returns the number of values that are contained inside the 
specified array. Notice that zeros and empty strings at the end of this array 
are not counted towards this number.

For 举例:

    setarray @array[0], 100, 200, 300, 400, 500, 600;
    set @arraysize,getarraysize(@array);

This will make @arraysize == 6. But if you try this:

    setarray @array[0], 100, 200, 300, 400, 500, 600, 0;
    set @arraysize,getarraysize(@array);
    
@arraysize will still equal 6, even though you've set 7 values.    

---------------------------------------

*getelementofarray(<array name>,<index>)

This function will return an array's element when given an index.

    // This will find the 2nd array value
    getelementofarray(@array,1)

Pretty pointless now when we have

    @array[1]

which has the same effect.

---------------------------------------

*readparam(<parameter number>)

This function will return the basic stats of an invoking character, referred to 
by the parameter number. Instead of a number, you can use a parameter name if it 
is defined in "db/const.txt".

For reference, in there these things are defined:

StatusPoint, BaseLevel, SkillPoint, Class, Upper, Zeny, Sex, Weight, MaxWeight,
JobLevel, BaseExp, JobExp, NextBaseExp, NextJobExp, Hp, MaxHp, Sp, MaxSp,
BaseJob, Karma, Manner, bVit, bDex, bAgi, bStr, bInt, bLuk

All of these also behave as variables, but don't expect to be able to just 'set' 
all of them - some will not work for various internal reasons.

    // This would return how many status points you haven't spent yet
    readparam(9)

Using this particular information as a function call is not required. Just 
putting

    StatusPoint 

will give you the same result, and some of these parameters work just like 
variables (i.e. you can 'set Zeny,100' to make the character have 100 zeny, 
destroying whatever zeny they had before, or 'set Zeny,Zeny+100' to give them 
100 zeny)

You can also use this command to get stat values:

    readparam(bVit)
    if(readparam(bVit)<=77) goto L_End;
    mes "Only people with over 77 Vit are reading this";
L_End:
    close;

---------------------------------------

*getcharid(<类型>{,"<character name>"})

This function will return a unique ID number of the invoking character, or, if a 
character name is specified, of that character.

Type is the kind of associated ID number required:

 0 - Character ID number.
 1 - Party ID number.
 2 - Guild ID number.
 3 - Account ID number.

For most purposes other than printing it, a number is better to have than a name 
(people do horrifying things to their character names).

If the character is not in a party or not in a guild, the function will return 0 
if guild or party number is requested. If a name is specified and the character 
is not found, 0 is returned.

If getcharid(0) returns a zero, the script got called not by a character and 
doesn't have an attached RID. Note that this will cause the map server to
print "player not attached!" error messages, so it is preferred to use
"playerattached" to check for the character attached to the script.

if( getcharid(2) == 0 ) mes "Only members of a guild are allowed here!";

---------------------------------------

*getchildid()
*getmotherid()
*getfatherid()

These functions return the characters (child/mother/father) ID

    if (getmotherid()) mes "Oh... I know your mother's ID:"+getmotherid();

---------------------------------------

*ispartneron()

This function returns 1 if the invoking character's marriage partner is 
currently online and 0 if they are not or if the character has no partner.

---------------------------------------

*getpartnerid()

This function returns the character ID of the invoking character's marriage 
partner, if any. If the invoking character is not married, it will return 0, 
which is a quick way to see if they are married:

    if (getpartnerid()) mes "I'm not going to be your girlfriend!";
    if (getpartnerid()) mes "You're married already!";

---------------------------------------

*getpartyname(<party id>)

This function will return the name of a party that has the specified ID number. 
If there is no such party ID, "null" will be returned.

Lets say the ID of a party was saved as a global variable:

    // This would return the name of the party from the ID stored in a variable
    mes "You're in the '"+getpartyname($@var)"' party, I know!";

---------------------------------------

*getpartymember <party id>{,<类型>};

Thank you to HappyDenn for all this information.

This command will find all members of a specified party and returns their names 
(or character id or account id depending on the value of "type") into an array
of temporary global variables. There's actually quite a few commands like this
which will fill a special variable with data upon execution and not do anything
else.

Upon executing this,

$@partymembername$[] is a global temporary stringarray which contains all the 
                     names of these party members
                     (only set when type is 0 or not specified)

$@partymembercid[]   is a global temporary number array which contains the 
                     character id of these party members.
                     (only set when type is 1)

$@partymemberaid[]   is a global temporary number array which contains the 
                     account id of these party members.
                     (only set when type is 2)

$@partymembercount   is the number of party members that were found.

The party members will (apparently) be found regardless of whether they are 
online or offline. Note that the names come in no particular order.

Be sure to use $@partymembercount to go through this array, and not 
'getarraysize', because it is not cleared between runs of 'getpartymember'. If 
someone with 7 party members invokes this script, the array would have 7 
elements. But if another person calls up the NPC, and he has a party of 5, the 
server will not clear the array for you, overwriting the values instead. So in 
addition to returning the 5 member names, the 6th and 7th elements from the last 
call remain, and you will get 5+2 members, of which the last 2 don't belong to 
the new guy's party. $@partymembercount will always contain the correct number, 
(5) unlike 'getarraysize()' which will return 7 in this case.

举例:

   // get the character's party ID
       getpartymember(getcharid(1));

   // immediately copy $@partymembercount value to a new variable, since
   // you don't know when 'getpartymember' will get called again for someone 
   // else's party, overwriting your global array.
       set @partymembercount,$@partymembercount;

   // copy $@partymembername array to a new array
       copyarray @partymembername$[0],$@partymembername$[0],@partymembercount;

   //list the party members in NPC dialog
       set @count,0;
   L_DisplayMember:
       if(@count == @partymembercount) goto L_DisplayMemberEnd;
       mes (@count + 1) + ". ^0000FF" + @partymembername$[@count] + "^000000";
       set @count,@count+1;
       goto L_DisplayMember;
   L_DisplayMemberEnd:
       close;

---------------------------------------

*getpartyleader(<party id>{,<类型>});

This function returns some information about the given party-id's leader.
When type is ommitted, the default information retrieved is the leader's name.
Possible types are:

	1: Leader account id
	2: Leader character id
	3: Leader's class
	4: Leader's current map name
	5: Leader's current level as stored on the party structure (may not be
	   current level if leader leveled up recently).

If retrieval fails (leader not found or party does not exist), this function
returns "null" instead of the character name, and -1 for the other types.

---------------------------------------

*getlook(<类型>)

This function will return the number for the currentcharacter look value 
specified by type. See 'setlook' for valid look types.

This can be used to make a certain script behave differently for characters 
dressed in black. :)

---------------------------------------

*getsavepoint(<information type>)

This function will return information about the invoking character's save point. 
You can use it to let a character swap between several recorded savepoints. 
Available information types are:

 0 - Map name (a string)
 1 - X coordinate
 2 - Y coordinate

---------------------------------------

*pushpc <方向>,<单元格>;

该指令把当前关联角色向指定方向推指定单元格。方向和NPC定义时用的一样，
也能用 DIR_* 等恒量代替 (db/const.txt).

这种击退不收道具或地图标签限制, 只有障碍物有效。如果没有足够空间被击退
(例如有墙), 角色会被推至障碍物。

    // 把角色从当前位置向3点钟方向推5格
    pushpc DIR_EAST, 5;

---------------------------------------

*searchstores <次数>,<效果>;

打开商店搜索窗口, 用来搜索露天商店和采购商店。
数量表示一次搜索的最大商店量。
效果表示结果中的道具被双击时的效果，数值如下：

	0 = 如果商店和玩家在同一地图时，在小地图显示商店位置，并以黄色高亮显示商店牌
	1 = 无视距离直接打开商店

举例:

	// Item Universal_Catalog_Gold (搜索10次, 效果: 直接打开)
	searchstores 10,1;

---------------------------------------
\\
2,2 Item-related commands
\\
---------------------------------------

*getequipid(<equipment slot>)

This function returns the item ID of the item equipped in the equipment slot 
specified on the invoking character. If nothing is equpped there, it returns -1. 
Valid equipment slots are:

EQI_HEAD_TOP (1)  - Upper head gear
EQI_ARMOR (2)     - Armor (Where you keep your Jackets and Robes)
EQI_HAND_L (3)    - What is in your Left hand.
EQI_HAND_R (4)    - What is in your Right hand.
EQI_GARMENT (5)   - The garment slot (Mufflers, Hoods, Manteaus)
EQI_SHOES (6)     - What foot gear the player has on.
EQI_ACC_L (7)     - Accessory 1.
EQI_ACC_R (8)     - Accessory 2.
EQI_HEAD_MID (9)  - Middle Headgear (masks and glasses)
EQI_HEAD_LOW (10) - Lower Headgear (beards, some masks)
EQI_COSTUME_TOP (11)  - Upper Costume Headgear
EQI_COSTUME_MID (12) - Middle Costume Headgear
EQI_COSTUME_LOW (13) - Lower Costume Headgear
EQI_COSTUME_GARMENT (14) - Costume Garment

Notice that a few items occupy several equipment slots, and if the character is 
wearing such an item, 'getequipid' will return it's ID number for either slot.

Can be used to check if you have something equiped, or if you haven't got 
something equiped:

        if(getequipid(EQI_HEAD_TOP)==2234) goto L_WearingTiara;
        mes "Come back when you have a Tiara on";
        close;
    L_WearingTiara:
        mes "What a lovely Tiara you have on";
        close;

You can also use it to make sure people don't pass a point before removing an 
item totally from them. Let's say you don't want people to wear Legion Plate 
armor, but also don't want them to equip if after the check, you would do this:

        if ((getequipid(EQI_ARMOR) == 2341) || (getequipid(EQI_ARMOR) == 2342) goto L_EquipedLegionPlate; 
    // the || is used as an or argument, there is 2341 and 2342 cause there are 
    // two different legion plate armors, one with a slot one without.
        if ((countitem(2341) > 0) || (countitem(2432) > 0) goto L_InventoryLegionPlate;
        mes "I will lets you pass";
        close2;
        warp "place",50,50;
        end;
    L_EquipedLegionPlate:
        mes "You are wearing some Legion Plate Armor, please drop that in your stash before continuing";
        close;
    L_InventoryLegionPlate:
        mes "You have some Legion Plate Armor in your inventory, please drop that in your stash before continuing";
        close;

---------------------------------------

*getequipname(<equpment slot>)

Returns the jname of the item equipped in the specified equipment slot on the
invoking character, or an empty string if nothing is equipped in that position.
Does the same thing as getitemname(getequipid()). Useful for an NPC to state
what your are wearing, or maybe saving as a string variable.
See 'getequipid' for a full list of valid equipment slots.

        if( getequipname(EQI_HEAD_TOP) != "" )
	        mes "So you are wearing a "+getequipname(EQI_HEAD_TOP)+" on your head";
	else
	        mes "You are not wearing any head gear";

---------------------------------------

*getitemname(<item id>)

Given the database ID number of an item, this function will return the text 
stored in the 'japanese name' field (which, in eAthena, stores an english name 
the players would normally see on screen.)

---------------------------------------

*getbrokenid(<number>)

This function will search the invoking character's inventory for any broken 
items, and will return their item ID numbers. Since the character may have 
several broken items, 1 given as an argument will return the first one found, 2 
will return the second one, etc. Will return 0 if no such item is found.

    // Let's see if they have anything broken:
        if (getbrokenid(1)==0) goto Skip;
    // They do, so let's print the name of the first broken item:
        mes "Oh, I see you have a broken "+getitemname(getbrokenid(1))+" here!";
    Skip:
        mes "You don't have anything broken, quit bothering me.";

---------------------------------------

*getequipisequiped(<equipment slot>)

This functions will return 1 if there is an equipment placed on the specified
equipment slot and 0 otherwise. For a list of equipment slots 
see 'getequipid'. Function originally used by the refining NPCs:

    if (getequipisequiped(EQI_HEAD_TOP)) goto L_equipped;
        mes "[Refiner]";
        mes "Do you want me to refine your dumb head?";
        close;
    L_equipped:
        mes "[Refiner]";
        mes "That's a fine hat you are wearing there...";
        close;


---------------------------------------

*getequipisenableref(<equipment slot>)

Will return 1 if the item equipped on the invoking character in the specified 
equipment slot is refinable, and 0 if it isn't. For a list of equipment slots 
see 'getequipid'.

        if (getequipisenableref(EQI_HEAD_TOP)) goto L_Refine;
        mes "[Refiner]";
        mes "I can't refine this hat!...";
        close;
    L_Refine:
        mes "[Refiner]";
        mes "Ok I can refine this";
        close;

---------------------------------------

*getequiprefinerycnt(<equipment slot>)

Returns the current number of plusses for the item in the specified equipment 
slot. For a list of equipment slots see 'getequipid'.

Can be used to check if you have reached a maximum refine value, default for 
this is +10:

        if(getequiprefinerycnt(EQI_HEAD_TOP) < 10) goto L_Refine_HeadGear;
        mes "Sorry, it's not possible to refine hats better than +10";
        close;
    L_Refine_HeadGear:
        mes "I will now upgrade your "+getequipname(EQI_HEAD_TOP);

---------------------------------------

*getequipweaponlv(<equipment slot>)

This function returns the weapon level for the weapon equipped in the specified 
equipment slot on the invoking character. For a list of equipment slots see 
'getequipid'.

Only EQI_HAND_L and EQI_HAND_R normally make sense, since only weapons 
have a weapon level. You can, however, probably, use this field for other 
equippable custom items as a flag or something. 
If no item is equipped in this slot, or if it doesn't have a weapon level 
according to the database, 0 will be returned.

    switch (getequipweaponlv(EQI_HAND_R)) {
      case 1: mes "You are holding a lvl 1 weapon"; break;
		case 2: mes "You are holding a lvl 2 weapon"; break;
		case 3: mes "You are holding a lvl 3 weapon"; break;
      case 4: mes "You are holding a lvl 4 weapon"; break;
		case 5: mes "You are holding a lvl 5 weapon, hm, must be a custom design"; break;
		default: mes "Seems you don't have a weapon on"; break;
	 }

Or for the left hand, cause it can hold a weapon or a shield:

        if(getequipid(EQI_HAND_R)==0) goto L_NothingEquiped;
        switch (getequipweaponlv(EQI_HAND_L)) {
          case 0: mes "You are holding a shield, so it doesnt have a level"; break;
          case 1: mes "You are holding a lvl 1 weapon"; break;
          case 2: mes "You are holding a lvl 2 weapon"; break;
          case 3: mes "You are holding a lvl 3 weapon"; break;
          case 4: mes "You are holding a lvl 4 weapon"; break;
          case 5: mes "You are holding a lvl 5 weapon, hm, must be a custom design"; break;
		  }
        close;
    L_NothingEquiped:
        mes "Seems you have nothing equiped";
        close;

---------------------------------------

*getequippercentrefinery(<equipment slot>)

This function calculates and returns the percent value chance to successfully 
refine the item found in the specified equipment slot of the invoking character 
by +1. There is no actual formula, the sucess rate for a given weapon level of
a certain refine level is found in the db/refine_db.txt file. For a list of
equipment slots see 'getequipid'.

These values can be displayed for the player to see, or used to calculate the 
random change of a refine succeeding or failing and then going through with it 
(which is what the official NPC refinery scripts use it for)

// This will find a random number from 0 - 99 and if that is equal to or more 
// than the value recoverd by this command it will go to L_Fail
    if (getequippercentrefinery(EQI_HAND_L)<=rand(100)) goto L_Fail;

---------------------------------------

*getareadropitem("<地图名>",<x1>,<y1>,<x2>,<y2>,<item>)

This function will count all the items with the specified ID number lying on the 
ground on the specified map within the x1/y1-x2/y2 square on it and return that 
number.

This is the only function around where a parameter may be either a string or a 
number! If it's a number, it means that only the items with that item ID number 
will be counted. If it is a string, it is assumed to mean the 'english name' 
field from the item database. If you give it an empty string, or something that 
isn't found from the item database, it will count items number '512' (apples).

---------------------------------------

*getequipcardcnt(<equipment slot>)

This function will return the number of cards that have been compounded onto a 
specific equipped item for the invoking character. See 'getequipid' for a list 
of possible equipment slots.

---------------------------------------

*getinventorylist;
*getcartlist;

This command sets a bunch of arrays with a complete list of whatever the 
invoking character has in their inventory, including all the data needed to 
recreate these items perfectly if they are destroyed. Here's what you get:

		@inventorylist_id[]        - 道具id
		@inventorylist_amount[]    - 对应数量
		@inventorylist_equip[]     - 是否可以装备
		@inventorylist_refine[]    - 精炼值
		@inventorylist_identify[]  - 是否鉴定
		@inventorylist_attribute[] - 是否损坏
		@inventorylist_card1[]     - 卡片id
		@inventorylist_card2[]
		@inventorylist_card3[]
		@inventorylist_card4[]
		@inventorylist_expire[]    - 过期时间
		@inventorylist_freeze[]    - 冷冻截止时间
		@inventorylist_durability[]- 耐久度
		@inventorylist_maxdur[]    - 最大耐久度
		@inventorylist_count       - 物品栏中物品数
	*以上变量中把inventory改为cart即为对应的getcartlist用法。

This could be handy to save/restore a character's inventory, since no other 
command returns such a complete set of data, and could also be the only way to 
correctly handle an NPC trader for carded and named items who could resell them 
- since NPC objects cannot own items, so they have to store item data in 
variables and recreate the items.

Notice that the variables this command generates are all temporary, attached to  
the character, and integer. 

Be sure to use @inventorylist_count to go through these arrays, and not  
'getarraysize', because the arrays are not automatically cleared between runs  
of 'getinventorylist'.

---------------------------------------

*cardscnt()

This function will return the number of cards inserted into the weapon currently 
equipped on the invoking character.
While this function was meant for item scripts, it will work outside them:

    if (cardscnt()==4) mes "So you've stuck four cards into that weapon, think you're cool now?";

---------------------------------------

*getrefine()

This function will return the number of plusses the weapon currently equipped on 
the invoking character has been refined for.
While this function was meant for item scripts, it will work outside them:

    if (getrefine()==10) mes "Wow. That's a murder weapon.";

---------------------------------------

*getnameditem(<item id>,"<name to inscribe>");
*getnameditem("<item name>","<name to inscribe>");

This function is equivalent to using 'getitem', however, it will not just give 
the character an item object, but will also inscribe it with a specified 
character's name. You may not inscribe items with arbitrary strings, only with 
names of characters that actually exist. While this isn't said anywhere 
specifically, apparently, named items may not have cards in them, slots or no -
these data slots are taken by the character ID who's name is inscribed. Only one 
remains free and it's not quite clear if a card may be there.

This function will return 1 if an item was successfully created and 0 if it
wasn't for whatever reason. Like 'getitem', this function will also accept an
'english name' from the item database as an item name and will return 0 if no
such item exists.

---------------------------------------

*getitemslots(<item ID>)

This function will look up the item with the specified ID number in the database 
and return the number of slots this kind of items has - 0 if they are not 
slotted. It will also be 0 for all non-equippable items, naturally, unless 
someone messed up the item database. It will return -1 if there is no such item.

---------------------------------------

*getiteminfo(<item ID>,<类型>)

This function will look up the item with the specified ID number in the database 
and return the info set by TYPE argument.
It will return -1 if there is no such item.

Valid types are:
	0 - Buy Price; 1 - Sell Price; 2 - Item Type;
	3 - maxchance (Max drop chance of this item e.g. 1 = 0.01% , etc..
		if = 0, then monsters don't drop it at all (rare or a quest item)
		if = 10000, then this item is sold in NPC shops only
	4 - sex; 5 - equip; 6 - weight; 7 - atk; 8 - def; 9 - range;
	10 - slot; 11 - look; 12 - elv; 13 - wlv;

Check sample in nps\sample\getiteminfo.txt

---------------------------------------

*getequipcardid (<equipment slot>,<card slot>);

Returns value from equipped item slot in the indicated slot:

getequipcardid(num,slot)

where:
	num = equip position slot
	slot = 0,1,2,3 (Card Slot N)

This func returns CARD ID, 255,254,-255 (for card 0, if the item is produced) it's useful 
when you want to check item cards or if it's signed. Useful for such quests as 
"Sign this refined item with players name" etc;
	Hat[0] +4 -> Player's Hat[0] +4
	
--------------------------------------

*getitemslots (<item id>);

Returns the amount of slots the item has.

Example(s):

//@slots now has the amount of slots of the item with ID 1205.
	set @slots, getItemSlots(1205);
	
--------------------------------------
//
2,1.- End of item-related commands.
//
---------------------------------------

*getmapxy("<variable for map name>",<variable for x>,<variable for y>,<类型>{,"<search string>"})

This function will locate a character object, NPC object or pet's coordinates 
and place their coordinates into the variables specified when calling it. It 
will return 0 if the search was successful, and -1 if the parameters given were 
not variables or the search was not successful.

Type is the type of object to search for:

  0 - Character object
  1 - NPC object
  2 - Pet object
  3 - Monster object.
  
While 3 is meant to look for a monster object, no searching will be done if you 
specify type 3, and the function will always return -1.

The search string is optional. If it is not specified, the location of the 
invoking character will always be returned for types 0 and 2, the location of 
the NPC running this function for type 1.
If a search string is specified, for types 0 and 1, the character or NPC with 
the specified name will be located. If type is 3, the search will locate the 
current pet of the character who's name is given in the search string, it will 
NOT locate a pet by name.

What a mess. Example, a working and tested one now:

    prontera,164,301,3%TAB%script%TAB%Meh%TAB%730,{
        mes "My name is Meh. I'm here so that Nyah can find me.";
        close;
    }

    prontera,164,299,3%TAB%script%TAB%Nyah%TAB%730,{
        mes "My name is Nyah.";
        mes "I will now search for Meh all across the world!";
        if (getmapxy(@mapname$,@mapx,@mapy,1,"Meh")!=0) goto Notfound;
        mes "And I found him on map "+@mapname$+" at X:"+@mapx+" Y:"+@mapy+" !";
        close;
    Notfound:
        mes "I can't seem to find Meh anywhere!";
        close;
   }
   
Notice that NPC objects disabled with 'disablenpc' will still be located.

---------------------------------------

*getgmlevel()

This function will return the GM level of the account to which the invoking 
character belongs. If this is somehow executed from a console command, 99 will 
be returned, and 0 will be returned if the account has no GM level.

This allows you to make NPC's only accessable for certain GM levels, or behave 
specially when talked to by GMs.

   if (getgmlevel()) mes "What is your command, your godhood?";
   if (getgmlevel()) goto Wherever;

---------------------------------------

*gettimetick(<tick type>)

This function will return the system time in UNIX epoch time (if tick type is 2) 
or the time since the start of the current day in seconds if tick type is 1.
Passing 0 will make it return the server's tick, which is a measurement in
milliseconds used by the server's timer system. The server's tick is an
unsigned int which loops every ~50 days.

Just in case you don't know, UNIX epoch time is the number of seconds elapsed 
since 1st of January 1970, and is useful to see, for example, for how long the 
character has been online with OnPCLoginEvent and OnPCLogoutEvent, which could allow 
you to make an 'online time counted for conviction only' jail script.

---------------------------------------

*gettime(<类型>)

This function will return specified information about the current system time.

1 - Seconds (of a minute)
2 - Minutes (of an hour)
3 - Hour (of a day)
4 - Week day (0 for Sunday, 6 is Saturday)
5 - Day of the month.
6 - Number of the month.
7 - Year.
8 - Day of the year.

It will only return numbers.

    if (gettime(4)==6) mes "It's a Saturday. I don't work on Saturdays.";

---------------------------------------

*gettimestr(<format string>,<max length>)

This function will return a string containing time data as specified by the 
format string.

This uses the C function 'strfmtime', which obeys special format characters. For 
a full description see, for example, the description of 'strfmtime' at 
http://www.delorie.com/gnu/docs/glibc/libc_437.html
All the format characters given in there should properly work.
Max length is the maximum length of a time string to generate.

The example given in eAthena sample scripts works like this:

  mes gettimestr("%Y-%m/%d %H:%M:%S",21);
  
This will print a full date and time like 'YYYY-MM/DD HH:MM:SS'.

---------------------------------------

*getusers(<类型>)

This function will return a number of users on a map or the whole server. What 
it returns is specified by Type.

Type can be one of the following values, which control what will be returned:

  0 - Count of all characters on the map of the invoking character. 
  1 - Count of all characters in the entire server.
  8 - Count of all characters on the map of the NPC the script is
      running in. 

---------------------------------------

*getmapusers("<地图名>")

This function will return the number of users currently located on the specified 
map.

Currently being used in the PVP scripts to check if a PVP room is full of not, 
if the number returned it equal to the maximum allowed it will not let you 
enter.

---------------------------------------

*getareausers("<地图名>",<x1>,<y1>,<x2>,<y2>)

This function will return the count of connected characters which are located 
within the specified area - an x1/y1-x2/y2 square on the specified map.

This is useful for maps that are split into many buildings, such as all the 
"*_in" maps, due to all the shops and houses.

---------------------------------------

*getusersname;

This command will give the invoking character a list of names of the connected 
characters (including themselves) into an NPC script message window (see 'mes') 
paging it by 10 names as if with the 'next' command.

You need to put a 'close' after that yourself.

---------------------------------------
\\
2,2.- Guild-related commands
\\
---------------------------------------
*getguildname(<guild id>)

This function returns a guild's name given an ID number. If there is no such 
guild, "null" will be returned;

   // Would print what ever guild 10007 is, in my case this would return "AlcoROhics"
   mes "The guild "+GetGuildName(10007)+" are all nice people.";

   // This will do the same as above:
   set @var,10007;
   mes "We have some friends in "+GetGuildName(@var)+", you know.";

This is used all over the WoE controlling scripts. You could also use it for a 
guild-based event.

---------------------------------------

*getguildmaster(<guild id>)

This function return the name of the master of the guild which has the specified 
ID number. If there is no such guild, "null" will be returned.

// Would return the guild master of guild 10007, whatever that might be.
// In this example it would return "MissDjax" cause she owns "AlcoROhics" (10007)
    mes getguildmaster(10007)+" runs "+getguildname(10007);

Can be used to check if the character is the guildmaster of the specified guild.

Maybe you want to make a room only guildmasters can enter:

        set @GID,getcharid(2);
        if(@GID==0) goto L_NoGuild;
        if(strcharinfo(0)==getguildmaster(@GID)) goto L_GuildMaster;
        mes "Sorry you don't own the guild you are in";
        close;
    L_NoGuild:
        mes "Sorry you are not in a guild";
        close;
    L_GuildMaster:
        mes "Welcome guild master of "+GetGuildName(@GID);
        close;


---------------------------------------

*getguildmasterid(<guild id>)

This function will return the character ID number of the guildmaster of the 
guild specified by the ID. 0 if the character is not a guildmaster of any guild.

---------------------------------------

*getcastlename("<地图名>")

This function returns the name of the castle when given the map name for that 
castle. The data is read from 'db/castle_db.txt'.

---------------------------------------

*getcastledata("<地图名>",<type of data>)
*setcastledata "<地图名>",<type of data>,<value>;

This function returns the castle ownership information for the castle referred 
to by it's map name. Castle information stored in 'save\castle.txt' for the TXT 
version of the server and in 'guild_castle' table for the SQL version.

Valid types of data are:

 0 - Will make the map server request the castle data from the char server, and 
     always return 0. This, apparently, will also cause indirectly the execution 
     of an 'OnAgitInit:' event mentioned at the beginning of this document.
 1 - Guild ID
 2 - Castle Economy score.
 3 - Castle Defence score.
 4 - Number of times the economy was invested in today.
 5 - Number of times the defence was invested in today.
 9 - Will return 1 if a Kafra was hired for this castle, 0 otherwise.
10 - Is 1 if the 1st guardian is present (Soldier Guardian)
11 - Is 1 if the 2nd guardian is present (Soldier Guardian)
12 - Is 1 if the 3rd guardian is present (Soldier Guardian)
13 - Is 1 if the 4th guardian is present (Archer Guardian)
14 - Is 1 if the 5th guardian is present (Archer Guardian)
15 - Is 1 if the 6th guardian is present (Knight Guardian)
16 - Is 1 if the 7th guardian is present (Knight Guardian)
17 - Is 1 if the 8th guardian is present (Knight Guardian)

18-25 types of data will return current hit point values for guardians 1-8 
respectively.

The 'setcastledata' command will behave identically, but instead of returning 
values for the specified types of accessible data, it will alter them and cause 
them to be sent to the char server for storage. Data type of 0 won't do 
anything, obviously.

---------------------------------------

*getgdskilllv(<guild id>,<skill id>)
*getgdskilllv(<guild id>,"<skill name>")

This function returns the level of the skill <skill id> of the guild <guild id>.
If the guild does not have that skill, 0 is returned.
If the guild does not exist, -1 is returned.
Refer to 'db/skill_db.txt' for the full list of skills. (GD_* are guild skills)

---------------------------------------

*requestguildinfo <guild id>,"<event label>";

This command requests the guild data from the char server and merrily continues 
with the execution. Whenever the guild information becomes available (which 
happens instantly if the guild information is already in memory, or later, if it 
isn't and the map server has to wait for the char server to reply) it will run 
the specified event as in a 'doevent' call.

---------------------------------------

*getmapguildusers <mapname>,<guild id>;

Returns the amount of persons from the given guild that are on the given map.
Example(s):

//Will set the @persons variable to the amount of persons from the guild
//which ID's = 10 and are at prontera.

	set @persons,getMapGuildUsers "prontera",10;

---------------------------------------
//
2,2.- End of guild-related commands
//
---------------------------------------

*getskilllv(<skill id>)
*getskilllv("<skill name>")

This function returns the level of the specified skill that the invoking 
character has. If they don't have the skill, 0 will be returned. The full list 
of character skills is available in 'db/skill_db.txt'.

There are two main uses for this function, it can check whether the character 
has a skill or not, and it can tell you if the level is high enough.

Example 1:

        f (getskilllv(152)) goto L_HasSkillThrowStone;
        mes "You don't have Throw Stone";
        close;
    L_HasSkillThrowStone:
        mes "You have got the skill Throw Stone";
        close;

Example 2:

        if (getskilllv(28) >= 5) goto L_HasSkillHeallvl5orMore;
        if (getskilllv(28) == 10) goto L_HasSkillHealMaxed;
        mes "You heal skill is below lvl 5";
        close;
    L_HasSkillHeallvl6orMore:
        mes "Your heal lvl is 5 or more";
        close;
    L_HasSkillHealMaxed:
        mes "Your heal lvl has been maxed";
        close;

---------------------------------------

*getskilllist;

This command sets a bunch of arrays with a complete list of skills the 
invoking character has. Here's what you get:

@skilllist_id[]   - skill ids.
@skilllist_lv[]   - skill levels.
@skilllist_flag[] - see 'skill' for the meaning of skill flags.
@skilllist_count  - number of skills in the above arrays.

While 'getskillv' is probably more useful for most situations, this is the 
easiest way to store all the skills and make the character something else for a 
while. Advanced job for a day? :) This could also be useful to see how many 
skills a character has.

---------------------------------------

*getpetinfo(<类型>)

This function will return pet information for the pet the invoking character 
currently has active. Valid types are:

 0 - Unique pet ID number as stored by the char server and distinguishing it 
     from all other pets the characters actually have. This value is currently 
     useless, at most you can use it to tell pets apart reliably.
 1 - Pet class number as per 'db/pet_db.txt' - will tell you what kind of a pet it 
     is.
 2 - Pet name. Will return "null" if there's no pet. 
 3 - Pet friendly level (intimacy score). 1000 is full loyalty.
 4 - Pet hungry level. 100 is completely full.
 5 - Pet rename flag. 0 means this pet has not been named yet.
---------------------------------------

*gethominfo(<类型>)

This function works as a direct counterpart of 'getpetinfo':
 0 - Homunculus unique ID
 1 - Homunculus Class
 2 - Name
 3 - Friendly level (intimacy score). 100000 is full loyalty.
 4 - Hungry level. 100 is completely full.
 5 - Rename flag. 0 means this homunculus has not been named yet.
 6 - Homunculus level
---------------------------------------


*petstat(<标记>)

Returns current pet status, all are integers except name.
Returns 0 or "" if the player doesn't have pets.

Flags usable >>
PET_CLASS
PET_NAME
PET_LEVEL
PET_HUNGRY
PET_INTIMATE

举例:
set @i, petstat(PET_CLASS);


---------------------------------------

*getmonsterinfo(<mob ID>,<类型>)

This function will look up the monster with the specified ID number in the
mob database and return the info set by TYPE argument.
It will return -1 if there is no such monster (or the type value is invalid),
or "null" if you requested the monster's name.

Valid types are listed in const.txt:
	MOB_NAME	0		MOB_LV	1
	MOB_MAXHP	2		MOB_BASEEXP	3
	MOB_JOBEXP	4		MOB_ATK1	5
	MOB_ATK2	6		MOB_DEF	7
	MOB_MDEF	8		MOB_STR	9
	MOB_AGI		10		MOB_VIT		11
	MOB_INT		12		JOB_DEX		13
	MOB_LUK		14		MOB_RANGE	15
	MOB_RANGE2	16		MOB_RANGE3	17
	MOB_SIZE	18		MOB_RACE	19
	MOB_ELEMENT	20		MOB_MODE	21
	MVP_EXP		22

Check sample in nps\sample\getmonsterinfo.txt

---------------------------------------

*getmobdrops(<魔物 id>)

This command will find all drops of the specified mob and return the item IDs 
and drop percentages into arrays of temporary global variables. 
'getmobdrops' returns 1 if successful and 0 if the mob ID doesn't exist.

Upon executing this,

$@MobDrop_item[] 魔物掉落的物品id数列

$@MobDrop_rate[] 魔物掉落的物品的几率数列 (1 = .01%)

$@MobDrop_count  魔物掉落的物品数量

Be sure to use $@MobDrop_count to go through the arrays, and not 
'getarraysize', because the temporary global arrays are not cleared between 
runs of 'getmobdrops'. If a mob with 7 item drops is looked up, the arrays would 
have 7 elements. But if another mob is looked up and it only has 5 item drops, 
the server will not clear the arrays for you, overwriting the values instead. So 
in addition to returning the 5 item drops, the 6th and 7th elements from the 
last call remain, and you will get 5+2 item drops, of which the last 2 don't 
belong to the new mob. $@MobDrop_count will always contain the correct number 
(5), unlike 'getarraysize()' which would return 7 in this case.

举例:

	// get a Mob ID from the user
	input .@mob_id;
	
	if (getmobdrops(.@mob_id)) {	// 'getmobdrops' returns 1 on success
		// immediately copy global temporary variables into scope variables, 
		// since we don't know when 'getmobdrops' will get called again for 
		// another mob, overwriting your global temporary variables
		set .@count, $@MobDrop_count;
		copyarray .@item[0],$@MobDrop_item[0],.@count;
		copyarray .@rate[0],$@MobDrop_rate[0],.@count;
		
		mes getmonsterinfo(.@mob_id,MOB_NAME) + " - " + .@count + " drops found:";
		for( set .@i,0; .@i < .@count; set .@i,.@i +1 ) {
			mes .@item[.@i] + " (" + getitemname(.@item[.@i]) + ") " + .@rate[.@i]/100 + ((.@rate[.@i]%100 < 10) ? ".0":".") + .@rate[.@i]%100 + "%";
		}
	} else {
		mes "Unknown monster ID.";
	}
	close;

---------------------------------------

*getmapmobs("<地图名>")

This function will return the total count of monsters currently located on the 
specified map. If the map name is given as "this", the map the invoking 
character is on will be used. If the map is not found, or the invoker is not a 
character while the map is "this", it will return -1.

---------------------------------------

*getstrlen("<string>")

This function will return the length of the string given as an argument. It is 
useful to check if anything input by the player exceeds name length limits and 
other length limits and asking them to try to input something else.

---------------------------------------

*skillpointcount; 

Returns the total amount of skill points a character posesses (SkillPoint+SP's used in skills)
This command can be used to check the currently attached characters total amount of skillpoints.
This means the skillpoints used in skill are counted, and added to SkillPoints (number of skill points not used).

举例:

//This will set the temp character variable @skillPoints to the amount of skillpoints,
//and then tell the player the value.
	set @skillPoints, skillPointCount();
	mes "You have "+@skillPoints+" skillpoints in total!";
	
//Self-explanatory... :P
	if (skillPointCount() > 20)
		mes "Wow, you have more then 20 Skill Points in total!"; 

---------------------------------------

*getscrate(<effect type>,<base rate>{,<target ID number>})

This function will return the chance of a status effect affecting the invoking 
character, in percent, modified by the their current defense against said 
status. The 'base rate' is the base chance of the status effect being inflicted, 
in percent.

    if (rand(100) > getscrate(Eff_Blind, 50)) goto BlindHimNow;
  
You can see the full list of available effect types you can possibly inflict in 
'db/const.txt' under 'Eff_'.

It is pretty certain that addressing the target by an ID number will not 
currently work due to a bug.

---------------------------------------

========================
|3.- Checking commands.|
========================
-------------------------

*playerattached;

Returns the ID of the player currently attached to the script. It will return
0 if noone is attached, or if the attached player no longer exists on the map
server. It is wise to check for the attached player in script functions that
deal with timers as there's no guarantee the player will still be logged on
when the timer triggers. Note that the ID of a player is actually their
account ID.

-------------------------

*isloggedin(<account id>{,<char id>});

This function returns 1 if the specified account is logged in and 0 if they 
aren't. You can also pass the char_id to check for both account and char id.

会返回2，如果该玩家是离线挂店；返回3，如果玩家使用了@offline指令。

---------------------------------------

*checkweight(<item id>,<amount>)
*checkweight("<item name>",<amount>)

This function will compute and return 1 if the total weight of a specified 
number of specific items does not exceed the invoking character's carrying 
capacity, and 0 otherwise. It is important to see if a player can carry the 
items you expect to give them, failing to do that may open your script up to 
abuse or create some very unfair errors.

This function, in addition to checking to see if the player is capable of
holding a set amount of items, also ensures the player has room in their
inventory for the item(s) they will be receciving.

Like 'getitem', this function will also accept an 'english name' from the 
database as an argument.

    checkweight(502,10) // 10 apples

        if (checkweight(502,10) == 0 ) goto L_OverWeight;
        getitem 502,10;
        close;
    L_OverWeight:
        mes "Sorry you cannot hold this ammount of apples";
        close;

Or to put this another way:

        if (checkweight("APPLE",10)) goto L_Getapples;
        mes "Sorry you cannot hold this ammount of apples";
        close;
    L_Getapples:
        getitem 502,10;
        close;

Both these examples have the same effect.

---------------------------------------

*basicskillcheck()

This function will return the state of the configuration option 
'basic_skill_check' in 'battle_athena.conf'. It returns 1 if the option is 
enabled and 0 if it isn't. If the 'basic_skill_check' option is enabled, which 
it is by default, characters must have a certain number of basic skill levels to 
sit, request a trade, use emoticons, etc. Making your script behave differently 
depending on whether the characters must actually have the skill to do all these 
things might in some cases be required.

---------------------------------------

*checkoption(<option number>)
*checkoption1(<option number>)
*checkoption2(<option number>)
*setoption <option number>{,<标记>};

The 'setoption' series of functions check for a so-called option that is set on 
the invoking character. 'Options' are used to store status conditions and a lot 
of other non-permanent character data of the yes-no kind. For most common cases, 
it is better to use 'checkcart','checkfalcon','checkpeco' and other similar 
functions, but there are some options which you cannot get at this way. They 
return 1 if the option is set and 0 if the option is not set.

Option numbers valid for the first (option) version of this command are:

0x1     - Sight in effect.
0x2     - Hide in effect.
0x4     - Cloaking in effect.
0x8     - Cart number 1 present.
0x10    - Falcon present.
0x20    - Peco Peco present.
0x40    - GM Perfect Hide in effect.
0x80    - Cart number 2 present.
0x100   - Cart number 3 present.
0x200   - Cart number 4 present.
0x400   - Cart number 5 present.
0x800   - Orc head present.
0x1000  - The character is wearing a wedding sprite.
0x2000  - Ruwach is in effect.
0x4000  - Chasewalk in effect.
0x8000  - Flying or Xmas suit.
0x10000 - Sighttrasher.

Option numbers valid for the second version (opt1) of this command are:

1 - Petrified.
2 - Frozen.
3 - Stunned.
4 - Sleeping.
6 - Petrifying (the state where you can still walk)

Option numbers valid for the third version (opt2) of this command are:

0x1  - Poisoned.
0x2  - Cursed.
0x4  - Silenced.
0x8  - Signum Crucis (plays a howl-like sound effect, but otherwise no visible effects are displayed)
0x10 - Blinded.
0x80 - Deadly poisoned.

Option numbers (except for opt1) are bitmasks - you can add them up to check
 for several states, but the functions will return true if at least one of them
 is in effect.

'setoption' will set options on the invoking character. There are no second and 
third versions of this command, so you can only change the values in the first 
list (cloak, cart, ruwach, etc). if flag is 1 (default when omitted),
the option will be added to what the character currently has; if 0, the option is removed. 

This is definitely not a complete list of available option flag numbers. Ask a 
core developer (or read the source: src/map/status.h) for the full list.

---------------------------------------

*setcart {<类型>};
*checkcart()

If <类型> is 0 this command will remove the cart from the character.
Otherwise it gives the invoking character a cart. The cart given will be 
cart number <类型> and will work regardless of whether the character is a 
merchant class or not.
Note: the character needs to have the skill MC_PUSHCART to gain a cart

The accompanying function will return 1 if the invoking character has a cart 
(any kind of cart) and 0 if they don't.

    if (checkcart()) mes "But you already have a cart!";

---------------------------------------

*setfalcon {<标记>};
*checkfalcon()

If <标记> is 0 this command will remove the falcon from the character.
Otherwise it gives the invoking character a falcon. The falcon will be there 
regardless of whether the character is a hunter or not. It will (probably) not 
have any useful effects for non-hunters though.
Note: the character needs to have the skill HT_FALCON to gain a falcon

The accompanying function will return 1 if the invoking character has a falcon 
and 0 if they don't.

    if (checkfalcon()) mes "But you already have a falcon!";

---------------------------------------

*setwarg {<标记>};
*checkwarg()

If <标记> is 0 this command will remove the warg from the character.
Otherwise it gives the invoking character a warg. The warg will be there 
regardless of whether the character is a ranger or not. It will (probably) not 
have any useful effects for non-rangers though.
Note: the character needs to have the skill 狼训练 to gain a warg

The accompanying function will return 1 if the invoking character has a warg
and 0 if they don't.

    if (checkwarg()) mes "But you already have a warg!";

---------------------------------------

*setriding {<标记>};
*checkriding()

If <标记> is 0 this command will remove the mount from the character.
Otherwise it give the invoking character a PecoPeco (if they are a Knight 
series class) or a GrandPeco (if they are a Crusader seriesclass). Unlike 
'setfalcon' and 'setcart' this will not work at all if they aren't of a class 
which can ride.
Note: the character needs to have the skill KN_RIDING to gain a mount

The accompanying function will return 1 if the invoking character is riding a 
bird and 0 if they don't.

    if (checkriding()) mes "PLEASE leave your bird outside! No riding birds on the floor here!";

---------------------------------------

*checkvending ({"<player name>"})
*checkchatting ({"<Player Name>"})

If the player's name is given, this command checks for that player
to be online and wether he/she is chatting or vending.
When no name is given, the attached player is used for checking.
Returns true or false (1 or 0) when the player is chatting/vending or not.

Example(s):
if (checkVending("Aaron")) mes "Aaron is currently vending!";	
	//This will check if Aaron is vending, and if so, put a message in front
	//of the attached player saying Aaron is vending.

if (checkChatting()) mes "You are currently chatting!";
	//This will check if you're in a chat room or not
	
---------------------------------------

*agitcheck()
*agitcheck2()

This function will let you check whether the server is currently in WoE mode.
It will return 1 if the War of Emperium is on and 0 if it isn't.

---------------------------------------

*isnight()
*isday()

These functions will return 1 or 0 depending on whether the server is in night 
mode or day mode. 'isnight' returns 1 if it's night and 0 if it isn't, 'isday' 
the other way around. They can be used interchangeably, pick the one you like 
more:

    // These two are equivalent:
    if (isday()) mes "I only prowl in the night.";
    if (isnight()!=1) mes "I only prowl in the night.";

---------------------------------------
\\
3,1.- Item-related commands
\\
---------------------------------------
*isequipped(<id>{,<id>{,<id>{,<id>}}})

This function will return 1 if the invoking character has all of the item 
IDs given equipped (if card IDs are passed, then it checks if the cards are
inserted into slots in the equipment they are currently wearing). Theorically
there is no limit to the number of items that may be tested for at the same time. 
If even one of the items given is not equipped, 0 will be returned.

    // (Poring,Santa Poring,Poporing,Marin)
    if (isequipped(4001,4005,4033,4196)) mes "Wow! You're wearing a full complement of possible poring cards!";
    // (Poring)
    if (isequipped(4001)) mes "A poring card is useful, don't you think?";
    
The function was meant for item scripts to support the cards released by Gravity 
in February 2005, but it will work just fine in normal NPC scripts.

---------------------------------------

*isequippedcnt(<card id>{,<card id>{,<card id>{,<card id>}}})

This function is similar to 'isequipped', but instead of 1 or 0, it will return 
the number of cards in the list given that were found on the invoking character.

    if (isequippedcnt(4001,4005,4033,4196)=4) mes "Finally got all four poring cards?";

---------------------------------------

*checkequipedcard(<card id>)

This function will return 1 if the card specified by it's item ID number is 
inserted into any equipment they have in their inventory, currently equipped or 
not.

---------------------------------------

*getequipisidentify(<equipment slot>)

This function will return 1 if an item in the specified equipment slot is 
identified and 0 if it isn't. Since you can't even equip unidentified equipment, 
there's a question of whether it can actually end up there, and it will normally 
return 1 all the time if there is an item in this equipment slot.
Which is kinda pointless.
For a list of equipment slots see 'getequipid'.

---------------------------------------
//
3,1.- End of item-related commands
//
---------------------------------------

==============================
|4.- Player-related commands.|
==============================
-------------------------

*attachrid(<account ID>)
*detachrid;

A 'RID' is an ID of a character who caused the NPC script to run, as has been 
explained above in the introduction section. Quite a bit of commands want a RID 
to work, since they wouldn't know where to send information otherwise. And in 
quite a few cases the script gets invoked with a RID of zero (like through 
OnTime special labels). If an NPC script needs this, it can attach a specified 
character's id to itself. by calling the 'attachrid' function.

'attachrid' returns 1 if the character was found online and 0 if it wasn't.

This could also be used, while running in a script invoked by a character 
through talking to an NPC, to mess with other characters.
Detaching the RID will make the RID of the script zero.

---------------------------------------

*rid2name(<rid>)

Converts rid to name. Note: The player/monster/NPC must be online/enabled.
Good for PCKillEvent where you can convert 'killedrid' to the name of the player.

Note: rid2name may not produce correct character names since rid = account id.
      It will return the current online character of the account only.

---------------------------------------

*message "<character name>","<message>";

That command will send a message to the chat window of the character specified 
by name. The text will also appear above the head of that character. It will not 
be seen by anyone else.

---------------------------------------

*dispbottom "<message>";

This command will send the given message into the invoking character's chat 
window.

---------------------------------------

*warp "<地图名>",<x>,<y>;

This command will take the invoking character to the specifed map, and if 
wanted, specified coordinates too, but these can be random.

    warp "place",50,55;

This would take them to X 50 Y 55 on the map called "place". If your X and Y 
coordinates land on an unwalkable map square, it will send the warped character 
to a random place. Same will happen if they are both zero:

    warp "place",0,0;

Notice that while warping people to coordinates 0,0 will normally get them into 
a random place, it's not certain to always be so. Darned if I know where this is 
actually coded, it might be that this happens because square 0,0 is unwalkable 
on all official maps. If you're using custom maps, beware.

There are also three special 'map names' you can use.

"Random" will warp the player randomly on the current map.
"Save" and "SavePoint" will warp the player back to their savepoint.

---------------------------------------

*areawarp "<from map name>",<x1>,<y1>,<x2>,<y2>,"<to map name>",<x3>,<y3>;

This command is similar to 'warp', however, it will not refer to the invoking 
character, but instead, all characters within a specified area, defined by the 
x1/y1-x2/y2 square, will be warped. Nobody outside the area will be affected, 
including the activating character, if they are outside the area.

    areawarp "place",10,10,120,120,"place2",150,150;

Everyone that is in the area between X 10 Y 10 and X 120 Y 120, in a square 
shape, on the map called "place", will be affected, and warped to "place2" X 150 
Y 150

    areawarp "place",10,10,120,120,"place2",0,0;

By using ,0,0; as the destination coordinates it will take all the characters in 
the affected area to a random set of co-ordinates on "place2".

Like 'warp', areawarp will also explicitly warp characters randomly into the 
current map if you give the 'to map name' as "Random".

See also 'warp'.

---------------------------------------
 
*warpparty "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>"};
 
Warps a party to specified map and coordinate given the party ID, which you can get with
getcharid(1). You can also request another party id given a member's name with getcharid(1,<player_name>).

You can use the following "map names" for special warping behaviour:
Random:       All party members are randomly warped in their current map (as if they
              all used a fly wing)
SavePointAll: All party members are warped to their respective save point.
SavePoint:    All party members are warped to the save point of the currently
              attached player (will fail if there's no player attached).
Leader:       All party members are warped to the leader's position. The leader must
              be online and in the current map-server for this to work.

If you specify a from_mapname, warpparty will only affect those on that map.

举例:
mes "[Party Warper]";
mes "Here you go!";
close2;
set @id,getcharid(1);
warpparty "prontera",150,100,@id;
close;
 
---------------------------------------
 
*warpchar "<mapname>",<x>,<y>,<char_id>;
 
Warps another player to specified map and coordinate given the char id, which you can get with
getcharid(0,<player_name>). Obviously this is useless if you want to warp the same player that
is executing this script, unless it's some kind of "chosen" script. 
 
举例:
 
warpchar "prontera",150,100,20000001;
 
---------------------------------------
 
*warpguild "<mapname>",<x>,<y>,<guild_id>;
 
Warps a guild to specified map and coordinate given the guild id, which you can get with 
getcharid(2). You can also request another guild id given the member's name with getcharid(2,<player_name>).
 
举例:
 
warpguild "prontera",x,y,Guild_ID;

---------------------------------------

*warppartner("<地图名>",<x>,<y>);

This function will find the invoking character's marriage partner, if any, and 
warp them to the map and coordinates given. Go kidnap that spouse. :) It will 
return 1 upon success and 0 if the partner is not online, the character is not 
married, or if there's no invoking character (no RID). 0,0 will, as usual, 
normally translate to random coordinates.

---------------------------------------

*savepoint "<地图名>",<x>,<y>;
*save "<地图名>",<x>,<y>;

This command saves where the invoking character will return to upon 
'return to save point', if dead or in some other cases. The two versions are 
equivalent. Map name, X coordinate and Y coordinate should be perfectly obvious. 
This ignores any and all map flags, and can make a character respawn where no 
teleportation is otherwise possible.

    savepoint "place",350,75;

---------------------------------------

*heal <hp>,<sp>;

This command will heal a set amount of HP and/or SP on the invoking character.

    heal 30000,0; // This will heal 30,000 HP
    heal 0,30000; // This will heal 30,000 SP
    heal 300,300; // This will heal 300 HP and 300 SP

This command just alters the hit points and spell points of the invoking 
character and produces no other output whatsoever.

---------------------------------------

*itemheal <hp>,<sp>;

This command works on the invoking character like 'heal', however, it is not 
normally used in NPC scripts and will not work as expected there, but is used 
all over in item scripts. 

Unlike 'heal', which just alters hp/sp and doesn't do anything else at all, this 
command also shows healing animations for potions and other stuff, checks 
whether the potion was made by a famous alchemist and alters the amount healed, 
etc, etc. Since which kind of effect is shown depends on what item was used, 
using it in an NPC script will not have a desired effect.

There is also a nice example on using this with the 'rand' function, to give you 
a random ammount of healing.

    // This will heal anything thing from 100 to 150 HP and no SP
    itemheal rand(100,150),0; 

---------------------------------------

*percentheal <hp>,<sp>;

This command will heal the invoking character. It heals the character, but not 
by a set value - it adds percent of their maximum HP/SP.

    percentheal 100,0; // This will heal 100% HP
    percentheal 0,100; // This will heal 100% SP
    percentheal 50,50; // This will heal 50% HP and 50% SP

So the amount that this will heal will depend on the total ammount of HP or SP 
you have maximum. Like 'heal', this will not call up any animations or effects.

---------------------------------------

*recovery;

This command will revive and restore full HP and SP to all characters currently 
connected to the server.

---------------------------------------

*jobchange <job number>{,<upper flag>};

This command will change the job class of the invoking character.

    jobchange 1; // This would change your player into a Swordman
    jobchange 4002; // This would change your player into a Swordman High

This command does work with numbers, but you can also use job names. The full 
list of job names and the numbers they correspond to can be found in 
'db/const.txt'.

    // This would change your player into a Swordman
    jobchange Job_Swordman; 
    // This would change your player into a Swordman High
    jobchange Job_Swordman_High; 

'upper flag' can alternatively be used to specify the type of job one changes
to. For example, jobchange Job_Swordman,1; will change the character to a high
swordsman. The upper values are:
-1 (or when omitted): preserves the current job type.
0: Normal/standard classes
1: High/Advanced classes
2: Baby classes

This command will also set a permanent character-based variable 
'jobchange_level' which will contain the job level at the time right before 
changing jobs, which can be checked for later in scripts.

---------------------------------------

*jobname (<job number>)

This command retrieves the name of the given job using the msg_athena entries 550->650.

		mes "[Kid]";
		mes "I never thought I'd met a "+jobname(Class)+" here of all places.";
		close;

---------------------------------------

*eaclass ({<job number>})

This commands returns the "eA job-number" corresponding to the given class (if none is given, it returns uses
the invoking player's class as argument). The eA job-number is also a class number system, but it's one that
comes with constants which make it easy to convert among classes. The command will return -1 if you pass it a
job number which doesn't has a eA Job value equivalent.

	set @eac, eaclass();
	if ((@eac&EAJ_BASEMASK) == EAJ_SWORDMAN)
		mes "You must be a swordman, knight, crusader, paladin, high swordman, lord knight, baby swordman,";
		mes "baby knight or baby crusader.";
	if (@eac&EAJL_UPPER)
		mes "You are a rebirth job.";
	if ((@eac&EAJ_UPPERMASK) == EAJ_SWORDMAN)
		mes "You must be a Swordman, Baby Swordman or High Swordman.";

For more information on the eA Job System, see the docs/ea_job_system.txt file.

---------------------------------------
*roclass <job number> {,<gender>}

Does the opposite of eaclass. That is, given a eA Job class, it returns which is the corresponding RO class number. 
A gender is required because both Bard and Dancers share the same eA Job value (EAJ_BARDDANCER), if it isn't given, the
gender of the executing player is taken (if there's no player running the script, male will be used by default).
The command returns -1 when there isn't a valid class to represent the required job (for example, if you try to get the
baby version of a Taekwon class).

	set @eac, eaclass();
	//Check if class is already rebirth
	if (@eac&EAJL_UPPER) {
		mes "You look strong.";
		close;
	}
	set @eac, roclass(@eac|EAJL_UPPER);
	//Check if class has a rebirth version
	if (@eac != -1) {
		mes "Bet you can't wait to become a "+jobname(@eac)+"!";
		close;
	}

---------------------------------------

*changebase <job ID number>;

This will change the appearance of the invoking character to that of a specified 
job class. Nothing but appearance will change. This command is used in item 
scripts for "Wedding Dress" and "Tuxedo" so the character like job 22, which is 
the job number of the wedding sprites.

It would be entered in the equip bonus section of an item

2338,Wedding_Dress,Wedding Dress,5,43000,,500,,0,,0,119529470,7,0,16,,0,1,0,{ bonus bMdef,15; changebase 22; }

This command only works when inside item scripts.

---------------------------------------

*classchange <view id>,<类型>;

This command is very ancient, it's origins are clouded in mystery. 
It will send a 'display id change' packet to everyone in the immediate area of 
the NPC object, which will supposedly make the NPC look like a different sprite, 
an NPC sprite ID, or a monster ID. This effect is not stored anywhere and will 
not persist (Which is odd, cause it would be relatively easy to make it do so) 
and most importantly, will not work at all since this command was broken with 
the introduction of advanced classes. The code is written with the assumption 
that the lowest sprite IDs are the job sprites and the anything beyond them is 
monster and NPC sprites, but since the advanced classes rolled in, they got the 
ID numbers on the other end of the number pool where monster sprites float.

As a result it is currently impossible to call this command with a valid view 
id. It will do nothing whatsoever if the view ID is below 4047. Getting it to 
run will actually just crash the client.

It could be a real gem if it can be gotten to actually do what it's supposed to 
do, but this will only happen in a later SVN revision.

---------------------------------------

*changesex;

This command will change the gender for the attached character's account. If it 
was male, it will become female, if it was female, it will become male. The 
change will be written to the character server, the player will receive the 
message: "Need disconnection to perform change-sex request..." and the player 
will be immediately kicked to the login screen. When they log back in, they will 
be the opposite sex.

If there are any Dancer/Gypsy or Bard/Clown characters on the account, 
they will also have their skills reset upon 'changesex'.

---------------------------------------

*getexp <base xp>,<job xp>;

This command will give the invoking character a specified number of base and job 
experience points. Can be used as a quest reward. Negative values won't work.

    getexp 10000,5000;

You can also use the "set" command with the constants defined in 'db/const.txt':

    // These 2 combined has the same effect as the above command
    set BaseExp,BaseExp+10000;
    set JobExp,JobExp+5000;

You can also reduce the ammount of experience points:

    set BaseExp,BaseExp-10000;

Note that 'getexp' is now subject to the 'quest_exp_rate' config option, which
adjusts the gained value. If you want to bypass this, use the 'set' method.

---------------------------------------

*setlook <look type>,<look value>;
*changelook <look type>,<look value>;

'setlook' will alter the look data for the invoking character. It is used 
mainly for changing the palette used on hair and clothes: you specify which look 
type you want to change, then the palette you want to use. Make sure you specify 
a palette number that exists/is usable by the client you use.
'changelook' works the same, but is only client side (it doesn't save the look value).

    // This will change your hair(6), so that it uses palette 8, what ever your 
    // palette 8 is, your hair will use that colour

    setlook 6,8; 

    // This will change your clothes(7), so they are using palette 1, whatever 
    // your palette 1 is, your clothes will then use that set of colours.
    
    setlook 7,1; 

Here are the possible look types:
 
 0 - Base sprite
 1 - Hairstyle
 2 - Weapon
 3 - Head bottom
 4 - Head top
 5 - Head mid
 6 - Hair color
 7 - Clothes color
 8 - Shield
 9 - Shoes

Whatever 'shoes' means is anybody's guess, ask Gravity - the client does nothing 
with this value. It still wants it from the server though, so it is kept, but 
normally doesn't do a thing.
 
Only the look data for hairstyle, hair color and clothes color are saved to the 
char server's database and will persist. The rest freely change as the character 
puts on and removes equipment, changes maps, logs in and out and otherwise you 
should not expect to set them. In fact, messing with them is generally 
hazardous, do it at your own risk, it is not tested what will this actually do -
it won't cause database corruption and probably won't cause a server crash, but 
it's easy to crash the client with just about anything unusual.

However, it might be an easy way to quickly check for empty view IDs for 
sprites, which is essential for making custom headgear. 

Since a lot of people have different palettes for hair and clothes, it's 
impossible to tell you what all the colour numbers are. If you want a serious 
example, there is a Stylist script inside the default eAthena installation that 
you can look at, this may help you create a Stylist of your own: 
'custom\dye.txt'

---------------------------------------
\\
4,1.- Item-related commands
\\
---------------------------------------

*getitem <item id>,<amount>{,<account ID>};
*getitem "<item name>",<amount>{,<account ID>};

This command will give a specific amount of specified items to the target 
character. If the character is not online, nothing will happen.
If <character ID> is not specified, items will be created in the invoking 
character inventory instead.

In the first and most commonly used version of this command, items are 
referred to by their database ID number found inside 'db/item_db.txt'.

    getitem 502,10 // The person will receive 10 apples
    getitem 617,1  // The person will receive 1 Old Violet Box

Giving an item ID of -1 will give a specified number of random items from the 
list of those that fall out of Old Blue Box. Unlike in all other cases, these 
will be unidentified, if they turn out to be equipment. This is exactly what's 
written in the Old Blue Box's item script.

Other negative IDs also correspond to other random item generating item tables:

Giving an item ID of -2 will produce the effects of Old Violet Box.
Giving an item ID of -3 will produce the effects of Old Card Album.
Giving an item ID of -4 will produce the effects of Gift Box.
Giving an item ID of -5 will produce the effects of Worn Out Scroll, which, in 
current SVN, drops only Jellopies anyway.

This transaction is logged if the log script generated transactions option is 
enabled.

You may also create an item by it's name in the 'english name' field in the 
item database:

    getitem "RED_POTION",10;

Which will do what you'd expect. If it can't find that name in the database, 
apples will be created anyway. It is often a VERY GOOD IDEA to use it like this.

This is used in pretty much all NPC scripts that have to do with items and 
quite a few item scripts. For more examples check just about any official script.

---------------------------------------

*getitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*getitem2 "<Item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};

This command will give an amount of specified items to the invoking character. 
If an optional character ID is specified, and that character is currently 
online, items will be created in their inventory instead. If they are not 
online, nothing will happen. It works essentially the same as 'getitem' (it even 
works for negative ID numbers the same way, which is kinda silly) but is a lot 
more flexible, since it allows you to give the player an item altered with it's 
specific properties. 

Those parameters that are different from 'getitem' are:

identify    - Whether you want the item to be identified or not, 0 unidentified, 
              1 identified.
refine      - For how many plusses will it be refined.
              It will not let you refine an item higher than +10, if you 
              specify more it'll still be 10.
attribute   - Whether the item is broken (1) or not (0) and NOT an elemental 
              attribute. 
card1,2,3,4 - If you want a card compound to it, place the card ID number into 
              the specific card slot. Card ID numbers also found in 
              'db/item_db.txt'

Card1-card4 values are also used to store name information for named items, as 
well as the elemental property of weapons and armor. You can create a named item 
in this manner, however, if you just need a named piece of standard equipment, 
it is much easier to the 'getnameditem' function instead.

You will need to keep these values if you want to destroy and then perfectly 
recreate a named item, for this see 'getinventorylist'.

If you still want to try creating a named item with this command because 
'getnameditem' won't do it for you cause it's too limited, you can do it like 
this. Careful, minor magic ahead.

    // First, let's get an ID of a character who's name will be on the item.
    // Only an existing character's name may be there.
    // Let's assume our character is 'Adam' and find his ID.
    
    set @charid,getcharid(0,"Adam");

    // Now we split the character ID number into two portions with a binary
    // shift operation. If you don't understand what this does, just copy it.
    
    set @card3, @charid & 65535;
    set @card4, @charid >> 16;

    // If you're inscribing non-equipment, @card1 must be 254.
    // Arrows are also not equipment. :)
    set @card1,254;
    
    // For named equipment, card2 means the Star Crumbs and elemental 
    // crystals used to make this equipment. For everything else, it's 0.
     
    set @card2,0;
    
    // Now, let's give the character who invoked the script some 
    // Adam's Apples:
    
    getitem2 512,1,1,0,0,@card1,@card2,@card3,@card4;

This wasn't tested with all possible items, so I can't give any promises, 
experiment first before relying on it.

To create equipment, continue this example it like this:

    // We've already have card3 and card4 loaded with correct
    // values so we'll just set up card1 and card2 with data
    // for an Ice Stiletto.

    // If you're inscribing equipment, @card1 must be 255.
    set @card1,255;
    
    // That's the number of star crumbs in a weapon.
    set @sc,2;
    
    // That's the number of elemental property of the weapon.
    set @ele,1;

    // And that's the wacky formula that makes them into
    // a single number.    
    set @card2,@ele+((@sc*5)<<8);

    // That will make us an Adam's +2 VVS Ice Stiletto:
    
    getitem2 1216,1,1,2,0,@card1,@card2,@card3,@card4;

Experiment with the number of star crumbs - I'm not certain just how much will 
work most and what it depends on. The valid element numbers are:

 1 - Ice, 2 - Earth 3 - Fire 4 - Wind.
    
You can, apparently, even create duplicates of the same pet egg with this 
command, creating a pet which is the same, but simultaneously exists in two 
eggs, and may hatch from either, although, I'm not sure what kind of a mess will 
this really cause.

---------------------------------------

* getnameditem <item name|item id>,<Character name|character ID>;

-Note: there's a total of 4 possible combinations of this command.
E.g: item name and character name, or with character id, etc...

Create a item signed with the given character's name. 
This is the same as using the hard(ly) explained way with getitem2.

The command returns 1 when the item is created succesfully, or 0 when failed.
Failure occurs when there is:
- no player attached
- Item name or ID is not valid
- The given character ID/name is offline.

举例:

//This will give the currently attached player a Aaron's Apple (if Aaron is online).
	getnameditem "Apple","Aaron"; 
	
//Self-explanatory (I hope).
	if (getnameitem("Apple,"Aaron")) {
		mes "You now have a Aaron's Apple!"; 
	}

---------------------------------------

*rentitem <item id>,<time>;
*rentitem "<item name>",<time>;

Creates a rental item in the attached character's inventory. The item will expire 
in <time> seconds and be automatically deleted. When receiving a rental item, 
the character will receive a message in their chat window. The character will 
also receive warning messages in their chat window before the item disappears.

This command can not be used to rent stackable items. Rental items cannot be 
removed from the character's inventory. (i.e. trade mask 123 in ../db/item_trade.txt)
Note: 'delitem' in an NPC script can still remove rental items.

---------------------------------------

*makeitem <item id>,<amount>,"<地图名>",<X>,<Y>;
*makeitem "<item name>",<amount>,"<地图名>",<X>,<Y>;

This command will create an item lying around on a specified map in the 
specified location.

 itemid   - Found in 'db/item_db.txt'
 amount   - Amount you want produced
 map name - The map name
 X        - The X coordinate
 Y        - The Y coordinate.

This item will still disappear just like any other dropped item. Like 'getitem', 
it also accepts an 'english name' field from the database and creates apples if 
the name isn't found.
If the map name is given as "this", the map the invoking character is on will be used.

---------------------------------------

*searchitem <array name>,"<item name>";

This command will fill the given array with the ID of items whose name matches the given one. It returns the number of items found. For performance reasons, the results array is limited to 10 items.

	mes "What item are you looking for?";
	input @name$;
	set @qty, searchitem(@matches[0],@name$);
	mes "I found "+@qty+" items:";
	for (set @i, 0; @i < @qty; set @i, @i+1)
		//Display name (eg: "Apple[0]")
		mes getitemname(@matches[@i])+"["+getitemslots(@matches[@i])+"]";

---------------------------------------

*delitem <item id>,<amount>{,<account ID>};
*delitem "<item name>",<amount>{,<account ID>};
*delcartitem <item id>,<amount>{,<account ID>};
*delcartitem "<item name>",<amount>{,<account ID>};
*delstorageitem <item id>,<amount>{,<account ID>};
*delstorageitem "<item name>",<amount>{,<account ID>};

This command will take a specified amount of items from the invoking character. 
As all the item commands, this one uses the ID of the item found inside 
'db/item_db.txt'. The items are destroyed - there is no way an NPC can simply 
own items and have an inventory of them, other as by destroying and recreating 
them when needed.

    delitem 502,10 // The person will lose 10 apples
    delitem 617,1  // The person will lose 1 Old Violet Box

It is always a good idea to to check if the player actually has the item before 
you take it from them, Otherwise, you could try to delete items which the 
players don't actually have, which won't fail and won't give an error message, 
but might open up ways to exploit your script.

Like 'getitem' this command will also accept an 'english name' field from the 
database. If the name is not found, nothing will be deleted.

---------------------------------------

*delitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*delitem2 "<Item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};

This command will take a specified amount of items from the invoking character. 
Check 'getitem2' to understand its expanded parameters.

---------------------------------------

*countitem(<item id>)
*countitem("<item name>")
*countcartitem(<item id>)
*countcartitem("<item name>")
*countstorageitem(<item id>)
*countstorageitem("<item name>")

This function will return the number of items for the specified item ID that the 
invoking character has in the inventory.

    mes "[Item Checker]";
    mes "Hmmm, it seems you have "+countitem(502)+" apples";
    close;

Like 'getitem', this function will also accept an 'english name' from the 
database as an argument.

If you want to state the number at the end of a sentence, you can do it by 
adding up strings:

    mes "[Item Checker]";
    mes "Hmmm, the total number of apples you are holding is "+countitem("APPLE");
    close;
    
---------------------------------------

*countitem2(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>)
*countitem2("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>)

Expanded version of 'countitem' function, used for created/carded/forged items.

This function will return the number of items for the specified item ID and
other parameters that the invoking character has in the inventory.
Check 'getitem2' to understand the arguments of the function.
    
---------------------------------------

*groupranditem <group id>;

Returns the item_id of a random item picked from the group specified. The
different groups and their group number are specified in db/item_group_db.txt

When used in conjunction with other functions, you can get a random item. For
example, for a random pet lure:

getitem groupranditem(15),1;

---------------------------------------

*enable_items;
*disable_items;

These commands enable item usage while an npc is running. When enable_items is
run, items can be used during scripts until disable_items is called. 
To avoid possible exploits, when enable_items is invoked, it will only enable
item usage while running that script in particular. Note that if a different
script also calls enable_items, it will override the last call (so you may
want to call this command at the start of your script without assuming the
effect is still in effect).

---------------------------------------

*itemskill <skill id>,<skill level>;
*itemskill "<skill name>",<skill level>;

This is a command meant for item scripts to replicate single-use skills. It will 
not work properly in NPC scripts a lot of the time because casting a skill is 
not allowed when there is a message window or menu on screen. If there isn't one 
cause you've made sure to run this when they already closed it, it should work 
just fine and even show a targeting pointer if this is a targeting skill.

// When you use Anodyne, you will cast Endure(8) level 1, 
// and "Endure" will appear above your head as you use it.
605,Anodyne,Anodyne,11,2000,0,100,,,,,10477567,2,,,,,{ itemskill 8,1; },{}


---------------------------------------

*produce <item level>;

This command will open a crafting window on the client connected to the invoking 
character. The 'item level' is a number which determines what kind of a crafting 
window will pop-up. You can see the full list of such item levels in 
'db/produce_db.txt' which determines what can actually be produced.
The window will not be empty only if the invoking character can actually produce 
the items of that type and has the appropriate raw materials in their inventory.

Valid item levels are:

 1   - Level 1 Weapons
 2   - Level 2 Weapons
 3   - Level 3 Weapons
 21  - Blacksmith's Stones and Metals
 22  - Alchemist's Potions, Holy Water, Assassin Cross's Deadly Poison
 23  - Elemental Converters

---------------------------------------

*cooking <dish level>;

This command will open a produce window on the client connected to the invoking 
character. The 'dish level' is the number which determines what kind of dish
level you can produce. You can see the full list of dishes that can be produced in 
'db/produce_db.txt'.

The window will be shown empty if the invoking character does not have enough of
the required incredients to cook a dish.

Valid dish levels are:

11 - Level 1 Dish
12 - Level 2 Dish
13 - Level 3 Dish
14 - Level 4 Dish
15 - Level 5 Dish
16 - Level 6 Dish
17 - Level 7 Dish
18 - Level 8 Dish
19 - Level 9 Dish
20 - Level 10 Dish

Altough it's required to set a dish level, it doesn't matter if you set it to 1
and you want to cook a level 10 dish, as long as you got the required incredients
to cook the dish the command works.

---------------------------------------

*successremovecards <equipment slot>;

This command will remove all cards from the item found in the specified 
equipment slot of the invoking character, create new card items and give them to 
the character. If any cards were removed in this manner, it will also show a 
success effect.

---------------------------------------

*failedremovecards <equipment slot>,<类型>;

This command will remove all cards from the item found in the specified 
equipment slot of the invoking character. 'type' determines what happens to the 
item and the cards:

 0 - will destroy both the item and the cards.
 1 - will keep the item, but destroy the cards.
 2 - will keep the cards, but destroy the item.
  
Whatever the type is, it will also show a failure effect on screen.

---------------------------------------

*repair <broken item number>;

This command repairs a broken peice of equipment, using the same list of broken 
items as available through 'getbrokenid'.

The official scripts seem to use the repair command as a function instead: 
'repair(<number>)' but it returns nothing on the stack. Probably only Valaris, 
who made it, can answer why is it so.

---------------------------------------

*successrefitem <equipment slot>;

This command will refine an item in the specified equipment slot of the invoking 
character by +1. For a list of equipment slots see 'getequipid'. This command 
will not only add the +1, but also display a 'refine success' effect on the 
character and put appropriate messages into their chat window. It will also give 
the character fame points if a weapon reached +10 this way, even though these 
will only take effect for blacksmith who will later forge a weapon.

The official scripts seem to use the 'successrefitem' command as a function 
instead: 'successrefitem(<number>)' but it returns nothing on the stack. 
This is since jAthena, so probably nobody knows for sure why is it so.

---------------------------------------

*failedrefitem <equipment slot>;

This command will fail to refine an item in the specified equipment slot of the 
invoking character. The item will be destroyed. This will also display a 'refine 
failure' effect on the character and put appropriate messages into their chat 
window.

The official scripts seem to use the 'failedrefitem' command as a function 
instead: 'failedrefitem(<number>)' but it returns nothing on the stack. This is 
since jAthena, so probably nobody knows for sure why is it so.

---------------------------------------

*failedrefitem2 <装备位置>,<精炼值>;

This command will fail to refine an item in the specified equipment slot of the 
invoking character. 道具精炼值会根据指定值减少. This will also display a 'refine 
failure' effect on the character and put appropriate messages into their chat 
window.

---------------------------------------

*unequip <equipment slot>;

This command will unequip whatever is currently equipped in the invoking 
character's specified equipment slot. For a full list of possible equipment 
slots see 'getequipid'.

If an item occupies several equipment slots, it will get unequipped from all of 
them. (Which is a good thing.)

---------------------------------------

*clearitem;

This command will destroy all items the invoking character has in their 
inventory. (that includes equipped items) It will not affect anything else, like 
storage or cart.

---------------------------------------

*equip <item id>;
*autoEquip <item id>,<option>;

These commands are to equip a equipment on the attached character. 
The equip function will equip the item ID given when the player has
this item in his/her inventory, while the autoequip function will 
equip the given item ID when this is looted. The option parameter of
the autoequip is 1 or 0, 1 to turn it on, and 0 to turn it off.

Example(s):

//This will equip a 1104 (falchion) on the character if this is in the inventory.
	equip 1104;
	
//The invoked character will now automatically equip a falchion when it's looted.
	autoequip 1104,1;
	
//The invoked character will no longer automatically equip a falchion.
	autoequip 1104,0;

---------------------------------------
//
4,1.- End of item-related commands
//
---------------------------------------

*openstorage;

This will open a character's Kafra storage window on the client connected to the 
invoking character. It does not check wherever it is run from, so you can allow 
any feasible NPC to open a kafra storage. (It's not certain whether this works 
in item scripts, but if it does, it could be interesting.)

The storage window might not open if a message box or a trade deal is present on 
screen already, so you should at least make sure the message box is closed 
before you open storage.

    mes "I will now open your stash for you";
    close2;
    openstorage;
    end;

---------------------------------------

*openmail;

This will open a character's Mail window on the client connected to the 
invoking character.

    mes "Close this window to open your mail inbox.";
    close2;
    openmail;
    end;

---------------------------------------

*openauction;

This will open the Auction window on the client connected to the invoking character.

    mes "Close this window to open the Auction window.";
    close2;
    openauction;
    end;

---------------------------------------
\\
4,2.- Guild-related commands
\\
---------------------------------------

*guildopenstorage()

This function works the same as 'openstorage' but will open a guild storage 
window instead for the guild storage of the guild the invoking character belongs 
to. This is a function because it returns a value - 0 if the guild storage was 
opened successfully and 1 if it wasn't. (Notice, it's a ZERO upon success.) 
Since guild storage is only accessible to one character at one time, it may fail 
if another character is accessing the guild storage at the same time.

This will also fail and return 2 if the character does not belong to any guild.

---------------------------------------

*guildchangegm(<guild id>,<new master's name>)

This function will change the Guild Master of a guild. The ID is the guild's
id, and the new guildmaster's name must be passed.

Returns 1 on success, 0 otherwise.

---------------------------------------

*guildgetexp <amount>;

This will give the specified amount of guild experience points to the guild the 
invoking character belongs to. It will silently fail if they do not belong to 
any guild.

---------------------------------------

*guildskill <skill id>,<level>
*guildskill "<skill name>",<level>

This command will bump up the specified guild skill by the specified number of 
levels. This refers to the invoking character and will only work if the invoking 
character is a member of a guild AND it's guildmaster, otherwise no failure 
message will be given and no error will occur, but nothing will happen - same 
about the guild skill trying to exceed the possible maximum. The full list of 
guild skills is available in 'db/skill_db.txt', these are all the GD_ skills at 
the end.

The flag parameter is currently not functional and it's a mystery of what it 
would actually do. (Though probably, like for character skills, it would allow 
temporary bumping.) Using this command will bump the guild skill up permanently.

// This would give your character's guild one level of Approval (GD_APPROVAL ID 
// 10000). Notice that if you try to add two levels of Approval, or add
// Approval when the guild already has it, it will only have one level of 
// Approval afterwards.
    guildskill 10000,1,0;

You might want to make a quest for getting a certain guild skill, make it hard 
enough that all the guild needs to help or something. Doing this for the Glory 
of the Guild skill, which allows your guild to use an emblem, is a good idea for 
a fun quest. (Wasting a level point on that is really annoying :D)

---------------------------------------
//
4,2 End of guild-related commands.
//
---------------------------------------

*resetlvl <action type>;

This is a character reset command, meant mostly for rebirth script supporting 
Advanced jobs, which will reset the invoking character's stats and level 
depending on the action type given. Valid action types are:

 1 - Base level 1, Job level 1, 0 skill points, 0 base xp, 0 job xp, wipes the 
     status effects (only the ones settable by 'setoption'), sets all stats to 1. 
     If the new job is 'Novice High', give 100 status points, give First Aid and 
     Play Dead skills.
 2 - Base level 1, Job level 1, 0 skill points, 0 base xp, 0 job xp. 
     Skills and attribute values are not altered.
 3 - Base level 1, base xp 0. Nothing else is changed.
 4 - Job level 1, job xp 0. Nothing else is changed.

In all cases it will also unequip everything the character has on.

Even though it doesn't return a value, it is used as a function in the official 
rebirth scripts. Ask AppleGirl why.

---------------------------------------

*resetstatus;

This is a character reset command, which will reset the stats on the invoking 
character and give back all the stat points used to raise them previously. 
Nothing will happen to any other numbers about the character.

Used in reset NPC's (duh!)

---------------------------------------

*resetskill;

This command takes off all the skill points on the invoking character, so they 
only have Basic Skill blanked out (lvl 0) left, and returns the points for them 
to spend again. Nothing else will change but the skills. Quest skills will also 
reset if 'quest_skill_reset' option is set to Yes in 'battle_athena.conf'. If 
the 'quest_skill_learn' option is set in there, the points in the quest skills 
will also count towards the total.

Used in reset NPC's (duh!)

---------------------------------------

*sc_start 	<effect type>,<ticks>,<extra argument>{,<target ID number>};
*sc_start2 	<effect type>,<ticks>,<extra argument>,<percent chance>{,<target ID number>};
*sc_start4	<effect type>,<ticks>,<value 1>,<value 2>,<value 3>,<value 4>{,<target ID number>};
*sc_end 	<effect type>{,<target ID number>};

These command bestow a status effect on the invoking character. This command is 
used a lot in the item scripts.

    // This would poison them for 10 min
    sc_start SC_Poison,600000,0;

Effect type is a number of effect, 'db/const.txt' lists the common (mostly 
negative) status effect types as constants, starting with 'SC_'. You can also 
use this to give someone an effect of a player-cast spell:

    // This will bless someone as if with Bless 10:
    sc_start 10,240000,10;
    
Extra argument's meaning differs depending on the effect type, for most effects 
caused by a player skill the extra argument means the level of the skill that 
would have been used to create that effect, for others it might have no meaning 
whatsoever. You can actually bless someone with a 0 bless spell level this way, 
which is fun, but weird.

The target ID number, if given, will cause the status effect to appear on a 
specified character, instead of the one attached to the running script. This has 
not been properly tested.

'sc_start2' is perfectly equivalent, but unlike 'sc_start', a status change 
effect will only occur with a specified percentage chance. 10000 given as the 
chance is equivalent to a 100% chance, 0 is a zero.

'sc_start4' is just like sc_start, however it takes four parameters for the
status change instead of one. What these values are depends on the status
change in question. For example, elemental armor defense takes the following
four values:
- val1 is the first element, val2 is the resistance to the element val1.
- val3 is the second element, val4 is the resistance to said element.
eg: sc_start4 SC_DefEle,60000,Ele_Fire,20,Ele_Water,-15;

'sc_end' will remove a specified status effect. If SC_All is used (-1), it will
do a complete removal of all statuses (although permanent ones will re-apply).

You can see the full list of status effects caused by skills in 
'src/map/status.h' - they are currently not fully documented, but most of that 
should be rather obvious.

---------------------------------------

*skilleffect <skill id>,<number>;
*skilleffect "<skill name>",<number>;

This command will display the visual and sound effects of a specified skill (see 
'db/skill_db.txt' for a full list of skills) on the invoking character's sprite. 
Nothing but the special effects and animation will happen. If the skill's normal 
effect displays a floating number, the number given will float up.

    // This will heal the character with 2000 hp, buff with 
    // Bless 10 and Increase AGI 5, and display appropriate
    // effects.
    mes "Blessed be!";
    skilleffect 28,2000;
    heal 2000,0;
    skilleffect 34,0;
    // That's bless 10.
    sc_start 10,240000,10;
    skilleffect 29,0;
    // That's agi 5
    sc_start 12,140000,5;

---------------------------------------

*npcskilleffect <skill id>,<number>,<x>,<y>;
*npcskilleffect "<skill name>",<number>,<x>,<y>;

This command behaves identically to 'skilleffect', however, the effect will not 
be centered on the invoking character's sprite, nor on the NPC sprite, if any, 
but will be centered at map coordinates given on the same map as the invoking 
character.

---------------------------------------

*specialeffect <效果编号>{,<发送目标>{,"<NPC名>"}};

该指令会在指定NPC的坐标上显示指定编号的特殊效果。
编号列表请看'doc/effect_list.txt'。
有些效果编号在有些版本的客户端里无效。(可以看到，下雨效果从2005年4月后的客户端都没有)

<NPC名> 会在其他NPC上显示 <效果编号>。如果指定NPC不存在，支持不会有任何效果。
如果指定了NPC，<发送目标>也必须同时使用。对<发送目标>使用AREA值会保留默认效果。
 
	// this will make the NPC "John Doe#1"
	// show the effect "EF_HIT1" specified by
	// Jane Doe. I wonder what John did...
	mes "[Jane Doe]";
	mes "Well, I never!";
	specialeffect EF_HIT1,AREA,"John Doe#1";
	close;

---------------------------------------

*specialeffect2 <effect number>{,<send_target>{,"<Player Name>"}};

This command behaves identically to the 'specialeffect', but the effect will be 
centered on the invoking character's sprite.

<Player name> parameter will display <effect number> on another Player than the
one currently attached to the script. Like with specialeffect, when specifying
a player, <send_target> must be supplied, specifying AREA will retain the default
behavior of the command.

---------------------------------------

*statusup <stat>;

This command will bump a specified stat of the invoking character up by one 
permanently. Stats are to be given as number, but you can use these constants to 
replace them:

bStr -  Strength
bVit -  Vitality
bInt -  Intelligence
bAgi -  Agility
bDex -  Dexterity
bLuk -  Luck

---------------------------------------

*statusup2 <stat>,<amount>;

This command will bump a specified stat of the invoking character up by the 
specified amount permanently. The amount can be negative. See 'statusup'.

    // This will decrease a character's Vit forever.
    statusup bVit,-1;

---------------------------------------

*bonus <bonus type>,<val1>;
*bonus2 <bonus type>,<val1>,<val2>;
*bonus3 <bonus type>,<val1>,<val2>,<val3>;
*bonus4 <bonus type>,<val1>,<val2>,<val3>,<val4>;
*bonus5 <bonus type>,<val1>,<val2>,<val3>,<val4>,<val5>;

These commands are meant to be used in item scripts. They will probably work 
outside item scripts, but the bonus will not persist for long. They, as 
expected, refer only to an invoking character.

You can find the full list of possible bonuses and which command to use for each 
kind in 'doc/item_bonus.txt'.

---------------------------------------

*autobonus <bonus script>,<rate>,<duration>{,<flag>,{<other script>}};
*autobonus2 <bonus script>,<rate>,<duration>{,<flag>,{<other script>}};
*autobonus3 <bonus script>,<rate>,<duration>,<skill id>,{<other script>};
*autobonus3 <bonus script>,<rate>,<duration>,"<skill name>",{<other script>};

These commands are meant to be used in item scripts. They will probably work 
outside item scripts, but the bonus will not persist for long. They, as 
expected, refer only to an invoking character.

What these commands do is 'attach' a script to the player which will get
executed on attack (or when attacked in the case of autobonus2).

Rate is the trigger rate of the script (1000 = 100%). 

Duration is the time that the bonus will last for since the script has triggered.

The optional argument 'flag' is used to classify the type of attack where the script
can trigger (it shares the same flags as the bAutoSpell bonus script):

Range criteria:
	BF_SHORT:  Trigger on melee attack
	BF_LONG:   Trigger on ranged attack
	Default:   BF_SHORT+BF_LONG
Attack type criteria:
	BF_WEAPON: Trigger on weapon skills 
	BF_MAGIC:  Trigger on magic skills 
	BF_MISC:   Trigger on misc skills
	Default:   BF_WEAPON
Skill criteria:
	BF_NORMAL: Trigger on normal attacks
	BF_SKILL:  Trigger on skills
	default:   If the attack type is BF_WEAPON (only) BF_NORMAL is used,
		   otherwise BF_SKILL+BF_NORMAL is used.

The difference between the optional argument 'other script' and the 'bonus script' is that,
the former one triggers only when attacking(or attacked) and the latter one runs on 
status calculation as well, which makes sure, within the duration, the "bonus" that get
lost on status calculation is restored. So, 'bonus script' is technically supposed to accept
"bonus" command only. And we usually use 'other script' to show visual effects.

In all cases, when the script triggers, the attached player will be the one
who holds the bonus. There is currently no way of knowing within this script  
who was the other character (the attacker in autobonus2, or the target in
autobonus and autobonus3).

//Grants a 1% chance of starting the state "all stats +10" for 10 seconds when
//using weapon or misc attacks (both melee and ranged skills) and shows a special 
//effect when the bonus is active.
	autobonus "{ bonus bAllStats,10; }",10,10000,BF_WEAPON|BF_MISC,"{ specialeffect2 EF_FIRESPLASHHIT; }";

---------------------------------------

*itembonus <持续时间>,<脚本>

作用类似于autobonus,但仅适用于消耗类道具

---------------------------------------

*skill <skill id>,<level>{,<标记>};
*skill "<skill name>",<level>{,<标记>};
*addtoskill <skill id>,<level>{,<标记>};
*addtoskill "<skill name>",<level>{,<标记>};

These commands will give the invoking character a specified skill. This is also 
used for item scripts.

Level is obvious. Skill id is the ID number of the skill in question as per 
'db/skill_db.txt'. It is not known for certain whether this can be used to give 
a character a monster's skill, but you're welcome to try with the numbers given 
in 'db/mob_skill_db.txt'.

Flag is 0 if the skill is given permanently (will get written with the character 
data) or 1 if it is temporary (will be lost eventually, this is meant for card 
item scripts usage.).  The flag parameter is optional, and defaults to 1 in 
'skill' and to 2 in 'addtoskill'.

Flag 2 means that the level parameter is to be interpreted as a stackable 
additional bonus to the skill level. If the character did not have that skill 
previously, they will now at 0+the level given.

// This will permanently give the character Stone Throw (TF_THROWSTONE,152), at 
// level 1.
    skill 152,1,0; 

---------------------------------------

*nude; 

This command will unequip anything equipped on the invoking character.

It is not required to do this when changing jobs since 'jobchange' will unequip 
everything not equippable by the new job class anyway.

---------------------------------------

*disguise <Monster ID>;
*undisguise;

This command disguises the current player with a monster sprite.
The disguise lasts until 'undisguise' is issued or the player logs out.

举例:

disquise 1002; //Yay! You're a Poring!!!
next;
undisguise; //Yay!!!! You're a human again!!

---------------------------------------
\\
4,3 Marriage-related commands
\\
---------------------------------------
*marriage("<spouse name>");

This function will marry two characters, the invoking character and the one 
referred to by name given, together, setting them up as each other's marriage 
partner. No second function call has to be issued (in current SVN at least) to 
make sure the marriage works both ways. The function returns 1 upon success, or 
0 if the marriage could not be completed, either because the other character 
wasn't found or because one of the two characters is already married.

This will do nothing else for the marriage except setting up the spouse ID for 
both of these characters. No rings will be given and no effects will be shown.

---------------------------------------

*wedding;

This command will call up wedding effects - the music and confetti - centered on 
the invoking character. Example can be found in the wedding script.

---------------------------------------

*divorce()

This function will un-marry the invoking character from whoever they were 
married to. Both will no longer be each other's marriage partner, (at least in 
current SVN, which prevents the cases of multi-spouse problems). It will return 
1 upon success or 0 if the character was not married at all.

This function will also destroy both wedding rings and send a message to both 
players, telling them they are now divorced.

---------------------------------------

*adopt "<parent name>","<parent name>","<novice name>";
*adopt("<parent name>","<parent name>","<novice name>")

This command will set up a novice as a baby of a married couple. All three are 
referred to by character name. The correct variables are set on all three 
characters in the same call. The command will unequip anything the novice has 
equipped and make them a Job_Baby class, as well as send them a 'your job has 
been changed' message.

Beware of calling this from inside a 'callfunc' function, cause upon successful 
adoption, this command returns a zero, as if it were a function. This is likely 
to screw up execution of a 'return' command. You may try to call it as a 
function instead, but it doesn't return anything upon an error, which may also 
cause script execution to throw up errors.

Nothing will happen (and nothing will be returned either) if either future 
parent is below base level 70 and/or if any of the three characters is not found 
online.

---------------------------------------
//
4,3.- End of marriage-related commands
//
---------------------------------------

*pcfollow <id>,<target id>;
*pcstopfollow <id>; 

Makes a character follow or stop following someone. This command does the same as the @follow command.
The main difference is that @follow can use character names, and this commands needs the Account ID for the target.

Example(s):

//This will make Aaron follow Bullah, when both of these characters are online.
	PCFollow getCharID(3,"Aaron"),getCharID(3,"Bullah");
	
//Makes Aaron stop following whoever he is following.
	PCStopFollow getCharID(3,"Aaron");
	
---------------------------------------

* pcblockmove <id>,<option>;

Prevents the given ID from moving when the option != 0, 0 enables the ID to move again.
ID should be able to be GID of a monster/npc or AID from a character.

Example(s):

//prevents the current char from moving away;
	pcblockmove getcharid(3),1;
	
//enables the current char to move again.	
	pcblockmove getcharid(3),0;

--------------------------------------- 

==================================
|5.- Mob / NPC -related commands.|
==================================
---------------------------------------

*monster     "<地图名>",<x>,<y>,"<name to show>",<mob id>,<amount>{,"<event label>"};
*areamonster "<地图名>",<x1>,<y1>,<x2>,<y2>,"<name to show>",<mob id>,<amount>{,"<event label>"};

This command will spawn a monster on the specified coordinates on the specified 
map. If the script is invoked by a character, a special map name, "this", will 
be recognised to mean the name of the map the invoking character is located at. 
This command works fine in the item scripts.

The same command arguments mean the same things as described above in the 
beginning of this document when talking about permanent monster spawns. Monsters 
spawned in this manner will not respawn upon being killed.

Unlike the permanent monster spawns, if the mob id is -1, a random monster will 
be picked from the entire database according to the rules configured in the 
server for dead branches. This will work for all other kinds of non-permanent 
monster spawns.

The only very special thing about this command is an event label, which is an 
optional parameter. This label is written like '<NPC object name>::<label name>' 
and upon the monster being killed, it will execute the script inside of the 
specified NPC object starting from the label given. The RID of the player 
attached at this execution will be the RID of the killing character.

    monster "place",60,100,"Poring",1002,1,"NPCNAME::OnLabel";

The coordinates of 0,0 will spawn the monster on a random place on the map.

The 'areamonster' command works much like the 'monster' command and is not 
significantly different, but spawns the monsters within a square defined by 
x1/y1-x2/y2.

Simple monster killing script:

        <Normal NPC object definition. Let's assume you called him NPCNAME.>
        mes "[Summon Man]";
        mes "Want to start the kill?";
        next;
        menu "Yes",L_Yes,"No",-;
        mes "[Summon Man]";
        mes "Come back later";
        close;
    L_Yes:
        monster "prontera",0,0,"Quest Poring",1002,10,"NPCNAME::OnPoringKilled";
        // By using 0,0 it will spawn them in a random place.
        mes "[Summon Man]";
        mes "Now go and kill all the Poring I summoned";
        // He summoned ten.
        close;
    OnPoringKilled:
        set $PoringKilled,$PoringKilled+1;
        if ($PoringKilled==10) goto L_AllDead;
        end;
    L_AllDead:
        announce "Summon Man: Well done all the poring are dead",3;
        set $PoringKilled,0;
        end;

For more good examples see just about any official 2-1 or 2-2 job quest script.

---------------------------------------

*areamobuseskill "<map name>",<x>,<y>,<range>,<mob id>,<skill id>,<skill level>,<cast time>,<cancelable>,<emotion>,<target type>;
*areamobuseskill "<map name>",<x>,<y>,<range>,<mob id>,"<skill name>",<skill level>,<cast time>,<cancelable>,<emotion>,<target type>;

This command will make all monsters of the specified mob ID in the specified 
area use the specified skill. Map name, x, and y define the center of the area, 
which extending <range> cells in each direction (ex: a range of 3 would create 
a 7x7 square). The skill can be specified by skill ID or name. <cast time> is in 
milliseconds (1000 = 1 second), and the rest should be self-explanatory. 

<target type> can be: 
	0 = self
	1 = the mob's current target
	2 = the mob's master
	3 = random target

Example:

	// spawn 1 Shining Plant in the 5x5 area centered on (155,188)
	areamonster "prontera",153,186,157,190,"Shining Plant",1083,1;
	// make the plant cast level 10 Cold Bolt on a random target
	areamobuseskill "prontera",155,188,2,1083,"MG_COLDBOLT",10,3000,1,e_gg,3;

---------------------------------------

- killmonster, killmonsterall
	killmonsterall <mapname>,8;为杀死所有魔物，掉落经验和物品。
	killmonsterall <mapname>,4;为杀死所有魔物，但不杀死WoE魔物。
	killmonsterall <mapname>,2;为杀死所有魔物，但不杀死玩家召唤魔物。
	killmonsterall <mapname>,1;为杀死所有魔物，触发魔物死亡事件。
	killmonsterall <mapname>;为杀死所有魔物。
	killmonster <mapname>,<eventlabel>;为杀死会触发<eventlabel>事件的魔物，且不触发该事件。
	killmonster <mapname>,<eventlabel>,1;为杀死会触发<eventlabel>事件的魔物，并触发该事件。
	killmonster <mapname>,<eventlabel>,2;为杀死会触发<eventlabel>事件的魔物，但不杀死玩家召唤魔物，但不触发该事件。
	killmonster <mapname>,<eventlabel>,3;为杀死会触发<eventlabel>事件的魔物，但不杀死玩家召唤魔物，并触发该事件。
	killmonster <mapname>,"All";为杀死所有不会重生魔物，并不触发任何事件。
	killmonster <mapname>,"All",1;为杀死所有不会重生魔物，并触发死亡事件。
	killmonster <mapname>,"All",2;为杀死所有不会重生魔物，但不杀死玩家召唤魔物，并不触发任何事件。
	killmonster <mapname>,"All",3;为杀死所有不会重生魔物，但不杀死玩家召唤魔物，且触发死亡事件。

---------------------------------------

*strmobinfo(<类型>,<monster id>);

This function will return information about a monster record in the database, as 
per 'db/mob_db.txt'. Type is the kind of information returned. Valid types are:

 1 - 'english name' field in the database, a string.
 2 - 'japanese name' field in the database, a string.
     All other returned values are numbers:
 3 - Level.
 4 - Maximum HP.
 5 - Maximum SP.
 6 - Experience reward.
 7 - Job experience reward.

---------------------------------------

*mobcount("<地图名>","<event label>")

This function will count all the monsters on the specified map that have a given 
event label and return the number or 0 if it can't find any. Naturally, only 
monsters spawned with 'monster' and 'areamonster' script commands can be like 
this.

However, apparently, if you pass this function an empty string for the event 
label, it should return the total count of normal permanently respawning 
monsters instead. With the current dynamic mobs system, where mobs are not kept 
in memory for maps with no actual people playing on them, this will return a 0 
for any such map.

---------------------------------------

*clone "<地图名>",<x>,<y>,"<event>",<char id>{,<master_id>{,<mode>{,<标记>,<duration>}}}

This command creates a monster which is a copy of another player. The first
four arguments serve the same purpose as in the monster script command, The
<char id> is the character id of the player to clone (player must be online).
If <master id> is given, the clone will be a 'slave/minion' of it. Master_id
must be a character id of another online player.

The mode can be specified to determine the behaviour of the clone, it's
values are the same as the ones used for the mode field in the mob_db. The
default mode is aggressive, assists, can move, can attack.

Flag can be either zero or one currently. If zero, the clone is a normal
monster that'll target players, if one, it is considered a summoned monster,
and as such, it'll target other monsters. Defaults to zero.

The duration specifies how long the clone will live before it is auto-removed.
Specified in seconds, defaults to no limit (zero).

Returned value is the monster ID of the spawned clone. If command fails,
returned value is zero.

---------------------------------------

*summon "Monster name",<monster id>{,<Time Out>{,"event label"}};

This command will summon a monster. (see also 'monster') Unlike monsters spawned
with other commands, this one will set up the monster to fight to protect the
invoking character. Monster name and mob id obey the same rules as the one given
at the beginning of this document for permanent monster spawns with the
exceptions mentioned when describing 'monster' command.

The effect for the skill 'Call Homonuculus' will be displayed centered on the
invoking character.

Timeout is the time in milliseconds the summon lives, and is set default 
to 60000 (1 minute). Note that also the value 0 will set the timer to default,
and it is not possible to create a spawn that lastst forever.
If an event label is given, upon the monster being killed, the event label will
run as if by 'donpcevent'.

// Will summon a dead branch-style monster to fight for the character.
summon "--ja--",-1;

---------------------------------------

*homevolution;

This command will try to evolve the current player's homunculus.
If it doesn't work, the /swt emoticon is shown.

To evolve a homunculus, the invoking player must have a homunculus,
the homunculus must not be the last evolution and
the homunculus must be on at least 91000/100000 intimacy with it's owner.

---------------------------------------
------------------------------------------------
//===========================================\\
||         Mob Control Suit Commands         ||
\\===========================================//
------------------------------------------------

---------------------------------------

* mobspawn (<monster name>,<monster ID>,<mapname>,<x>,<y>)
* mobRemove <GID>;

This is used to spawn a monster and return it's Game ID, to be used
in the unit/mobcontrol commands.

Note, I will use the stuff here in the examples for the unitcontrol.

Example(s):

//Spawns a poring named poi poi and put's it's GID in .GID.
	set .GID,mobspawn("Poi Poi",1002,"prontera",160,180);
//would kill our poring.
	mobRemove .GID;

---------------------------------------

* getmobdata(<GID>,<arrayname>)
* setmobdata <GID>,<parameter>,<new value>;

This is used to get and set special data related to the monster.
With getmobdata, the array given will be filled with the current data. In setmobdata
the indexes in the array would be used to set that data on the monster. 
Parameters (indexes) are: （getmobdata仅支持到47）

0 = 魔物ID						7  = y						14 = 发型		21 = 武器
1 = 等级						8  = 移动速度					15 = 发色		22 = 攻击速度
2 = HP							9  = mode (see doc/mob_db_mode_list.txt)	16 = 头下		23 = 面朝方向
3 = max HP						10 = special AI state			17 = 头中		24 = killer state (1 or 0)
4 = 主人 ID (aid of the master, summon)		11 = SC option				18 = 头上		25 = callback flag
5 = 地图编号						12 = 性别					19 = 衣服颜色		26 = 禁止移动 (1 or 0)
6 = x							13 = 外观ID (魔物 ID, Job ID)			20 = 盾		

27 = 阵营						28 = 目的坐标x					29 = 目的坐标y		30 = 射程
31 = atk1						32 = atk2					33 = amotion		34 = adelay
35 = dmotion						36 = def					37 = mdef						
38 = str						39 = agi					40 = vit
41 = int						42 = dex					43 = luk		44 = 体型
45 = 种族						46 = 属性					47 = 属性等级		48 = 显示名 (字符串)

Example(s):

//this will set all the mobdata in the @array variable. (@array[1] being level, @array[13] class etc)
	getmobdata .GID,@array;
	
//set the max hp of our poring to 1000.
	setmobdata .GID,3,1000;

getmobdata()指令返回值为0时，说明该魔物已经死亡。

---------------------------------------

* mobassist <GID>,<target id>;
This will make the monster assist the Target ID as if it was a summon of it.
Example(s):

/this will make our poring assist the current attached player! >:3
	mobassist .GID,getcharid(3);

---------------------------------------

* mobattach <GID>{,"<NPC Name>"};

GID is the GID of a monster, NPC or account id. The NPC running or
he NPC name given is used to attach the monster.

By attaching a monster, the NPC to which it is attached is ran on special actions by the monster.
The system will set specific data in the .ai_action variable array on the NPC invoked.
The special AI actions types are set in the .ai_action at place AI_ACTION_TAR_TYPE

More AI_ vars are set in const.txt, and you can also look at sample/monstercontroller.cpp:

---------------------------------------

* unitwalk <GID>,<x>,<y>{,<flag>};
* unitwalk <GID>,<mapid>;

This is one command, but can be used in two ways. If only the first argument is given,
the unit whose GID is given will start walking towards the map with the given mapid 
(we believe these are the mapindexes found in db/map_index.txt).

flag值若存在只能为2，即强制走动。魔物或者玩家在不能行走的状态下，例如晕眩、pcblockmove等状态，可以使用该命令行走。
GID为魔物GID，或者玩家AID。
该命令主要用于游戏脚本，即玩家不能控制走动，而系统可以控制其行走。

When 2 arguments are passed, the given unit will walk to the given x,y coordinates on 
the map where the unit currently is.

Example(s):

//Will move/walk the poring we made to the coordinates 150,150
	unitwalk .GID,150,150;

//Will move the poring towards alberta (if my assumed mapindexes are correct).
	unitwalk .GID,3;

---------------------------------------

* unitkill <GID>;
* unitwarp <GID>,<Mapname>,<x>,<y>;
* unitattack <GID>,<Target ID>;
* unitstop <GID>;
* unittalk <GID>,<Text>;
* unitemote <GID>,<Emote>;

Okay, these commands should be fairly self explaining.
For the emotions, you can look in db/const.txt for prefixes with e_

---------------------------------------

------------------------------------------------
//===========================================\\
||      End of Mob Control Suit Commands     ||
\\===========================================//
------------------------------------------------
---------------------------------------

*disablenpc "<NPC object name>";
*enablenpc "<NPC object name>";

These two commands will disable and enable, respectively, an NPC object 
specified by name. The disabled NPC will disappear from sight and will no longer 
be triggerable in the normal way. It is not clear whether it will still be 
accessible through 'donpcevent' and other triggering commands, but it probably 
will be. You can disable even warp NPCs if you know their object names, which is 
an easy way to make a map only accessible through walking half the time. Then 
you 'enablenpc' them back.

You can also use these commands to create the illusion of an NPC switching 
between several locations, which is often better than actually moving the NPC -
create one NPC object with a visible and a hidden part to their name, make a few 
copies, and then disable all except one.

---------------------------------------

*hideonnpc "<NPC object name>";
*hideoffnpc "<NPC object name>";

These commands will make the NPC object specified display as hidden/visible, 
even though not actually disabled per se. Hidden as in thief Hide skill, but 
unfortunately, not detectable by Ruwach or Sight.

As they are now, these commands are pointless, it is suggested to use 
'disablenpc'/'enablenpc', because these two commands actually unload the NPC 
sprite location and other accompanying data from memory when it is not used.
However, you can use these for some quest ideas (such as cloaking npcs talking 
while hidden then revealing.... you can wonder around =P

---------------------------------------

*doevent "<NPC object name>::<event label>";

This command will start a new execution thread in a specified NPC object at the 
specified label. The execution of the script running this command will not stop. 
No parameters may be passed with a doevent call.

The script of the NPC object invoked in this manner will run as if it's been 
invoked by the RID that was active in the script that issued a 'doevent'.

    place,100,100,1%TAB%script%TAB%NPC%TAB%53,{
        mes "This is what you will see when you click me";
        close;
    Label:
        mes "This is what you will see if the doevent is activated";
        close;
    }

    ....

    doevent "NPC::Label";

---------------------------------------

*donpcevent "{NPC NAME}::<event label>";

This command is kinda confusing cause it performs in two completely different 
ways.

If the event label is phrased like "::<label name>", all NPC objects that have a 
specified label in them will be invoked as if by a 'doevent', but no RID 
whatsoever will be attached while they execute.

Otherwise, if the label is given as "<NPC name>::<label name>", a label within 
the NPC object that runs this command will be called, but as if it was running 
inside another, specified NPC object. No RID will be attached to it in this case 
either.

This can be used for making another NPC react to an action that you have done 
with the NPC that has this command in it, i.e. show an emotion, or say 
something.

    place,100,100,1%TAB%script%TAB%NPC%TAB%53,{
        mes "Hey NPC2 copy what I do";
        close2;
        set @emo, rand(1,30);
        donpcevent "NPC2::Emo";
    Emo:
        emotion @emo;
        end;
    }

    place,102,100,1%TAB%script%TAB%NPC2%TAB%53,{
        mes "Hey NPC copy what I do";
        close2;
        set @emo, rand(1,30);
        donpcevent "NPC::Emo";
    Emo:
        emotion @emo;
        end;
    }

This will make both NPC perform the same random emotion from 1 to 30, and the 
emotion will appear above each of their heads.

---------------------------------------

*cmdothernpc "<npc name>","<command>";

This is simply "donpcevent <npc name>::OnCommand<command>".
It is an approximation of official server script language's 'cmdothernpc'.

---------------------------------------

*npctalk "<message>";

This command will display a message to the surrounding area as if the NPC object 
running it was a player talking - that is, above their head and in the chat 
window. The display name of the NPC will get appended in front of the message to 
complete the effect.

    // This will make everyone in the area see the NPC greet the character
    // who just invoked it.
    npctalk "Hello "+strcharinfo(0)+" how are you";

---------------------------------------

*setnpcdisplay("<npc name>", "<display name>", <class id>, <size>)
*setnpcdisplay("<npc name>", "<display name>", <class id>)
*setnpcdisplay("<npc name>", "<display name>")
*setnpcdisplay("<npc name>", <class id>)

Changes the display name and/or display class of the target npc.
Returns 0 is successful, 1 if the npc does not exist.
Size is 0 = norma 1 = small 2 = big.

Since trunk r11779

---------------------------------------
\\
5,1.- Time-related commands
\\
---------------------------------------
*addtimer <ticks>,"<NPC object name>::<label>";
*deltimer "<NPC object name>::<event label>";
*addtimercount <ticks>,"<NPC object name>::<event label>";

These commands will create and manage a player-based timer: 'addtimer' to 
create, 'deltimer' to destroy and 'addtimercount' to delay it by the specified 
number of ticks. For all three cases, the event label given is the identifier of 
that timer. A player can have multiple timers running at the same time, and 
there can even be multiple timers referencing the same label.

When this timer runs out, a new execution thread will start in the specified NPC 
object at the specified label, and the script will run attached to that player. 
If the specified label is not found, the map server will happily print an error.

The ticks are given in 1/1000ths of a second.

One more thing. These timers are stored as part of player data. If the player
logs out, all of these get immediately deleted, without executing the script.
If this behavior is undesirable, use some other timer mechanism (like 'sleep').

Example 1:
<NPC Header> {
	dispbottom "Starting a 5 second timer...";
	addtimer 5000, strnpcinfo(3)+"::On5secs";
	end;
On5secs:
	dispbottom "5 seconds have passed!";
	end;
}


---------------------------------------

*initnpctimer{ "<NPC name>" {, <Attach Flag>} } |
             { "<NPC name>" | <Attach Flag> };
*stopnpctimer{ "<NPC name>" {, <Detach Flag>}  } |
             { "<NPC name>" | <Detach Flag> };
*startnpctimer{ "<NPC name>" {, <Attach Flag>} } |
              { "<NPC name>" | <Attach Flag> };
*setnpctimer <tick>{,"<NPC name>"};
*getnpctimer(<type of information>{,"<NPC name>"});
*attachnpctimer {"<character name>"};
*detachnpctimer {"<NPC name>"};

This set of commands and functions will create and manage an NPC-based timer.
The NPC name may be omitted, in which case the calling NPC is used as target.

Contrary to addtimer/deltimer commands which let you have many different timers
referencing different labels in the same NPC, each with their own countdown,
'initnpctimer' can only have one per NPC object. But it can trigger many labels
and let you know how many were triggered already and how many still remain.

This timer is counting up from 0 in ticks of 1/1000ths of a second each. Upon 
creating this timer, the execution will not stop, but will happily continue 
onward. The timer will then invoke new execution threads at labels 
"OnTimer<time>:" in the NPC object it is attached to. 

To create the timer, use the 'initnpctimer', which will start it running. 
'stopnpctimer' will pause the timer, without clearing the current tick, while 
'startnpctimer' will let the paused timer continue.

By default timers do not have a RID attached, which lets them continue even
if the player that started them logs off. To attach a RID to a timer, you can
either use the optional "attach flag" when using 'initnpctimer/startnpctimer', 
or do it manually by using 'attachnpctimer'. Likewise, the optional flag of
stopnpctimer lets you detach any RID after stopping the timer, and by using
'detachnpctimer' you can detach a RID at any time.

Normally there is only a single timer per NPC, but as an exception, as long as
you attach a player to the timer, you can have multiple timers running at once,
because these will get stored on the players instead of the NPC.
NOTE: You need to attach the RID before the timer _before_ you start it to
get a player-attached timer. Otherwise it'll stay a NPC timer (no effect).

If the player that is attached to the npctimer logs out, the "OnTimerQuit:"
event label of that npc will be triggered, so you can do the appropiate
cleanup (the player is still attached when this event is triggered).

The 'setnpctimer' command will explicitly set the timer to a given tick.
'getnpctimer' provides timer information. Its parameter defines what type:

 0 - Will return the current tick count of the timer.
 1 - Will return 1 if there are remaining "OnTimer<ticks>:" labels in the 
     specified NPC waiting for execution.
 2 - Will return the number of times the timer has triggered and will trigger
     an "OnTimer<tick>:"  label in the specified NPC.

Example 1:

    <NPC Header> {
        initnpctimer;
        npctalk "I cant talk right now, give me 10 seconds";
        end;
    OnTimer5000:
        npctalk "Ok 5 seconds more";
        end;
    OnTimer6000:
        npctalk "4";
        end;
    OnTimer7000:
        npctalk "3";
        end;
    OnTimer8000:
        npctalk "2";
        end;
    OnTimer9000:
        npctalk "1";
        end;
    OnTimer10000:
        stopnpctimer;
        mes "[Man]";
        mes "Ok we can talk now";
    }

Example 2:

    OnTimer15000:
	npctalk "Another 15 seconds have passed.";
	setnpctimer 0;
	end;
       
    // This OnInit label will run when the script is loaded, so that the timer 
    // is initialised immediately as the server starts. It is dropped back to 0 
    // every time the NPC says something, so it will cycle continiously.
    OnInit:
        initnpctimer;
        end;

Example 3:

    mes "[Man]";
    mes "I have been waiting "+(getnpctimer(0)/1000)+" seconds for you";
    // we divide the timer returned by 1000 cause it will be displayed in 
    // milliseconds otherwise
    close;

Example 4:

    mes "[Man]";
    mes "Ok I will let you have 30 sec more";
    close2;
    setnpctimer (getnpctimer(0)-30000); 
    // Notice the 'close2'. If there were a 'next' there the timer would be 
    // changed only after the player pressed the 'next' button.
    end;
 
---------------------------------------
 
*sleep {<milliseconds>};
*sleep2 {<milliseconds>};
*awake "<NPC name>";

These commands are used to control the pause of a NPC.
sleep and sleep2 will pause the script for the given amount of milliseconds.
Awake is used to cancel a sleep. When awake is callen on a NPC it will run as
if the sleep timer ran out, and thus making the script continue. Sleep and sleep2
basically do the same, but the main difference is that sleep will not keep the rid,
while sleep2 does.

Examples:
	sleep 10000; //pause the script for 10 seconds and ditch the RID (so no player is attached anymore)
	sleep2 5000; //pause the script for 5 seconds, and continue with the RID attached.
	awake "NPC"; //Cancels any running sleep timers on the NPC 'NPC'.

---------------------------------------
//
5,1.- End of time-related commands
//

*announce "<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}}};

This command will broadcast a message to all or most players, similar to 
@kami/@kamib GM commands.

    announce "This will be shown to everyone at all in yellow.",0;

The region the broadcast is heard in (target), source of the broadcast
and the color the message will come up as is determined by the flags.

The flag values are coded as constants in db/const.txt to make them easier to use.

Target flags:
- bc_all: Broadcast message is sent server-wide (default).
- bc_map: Message is sent to everyone in the same map as the source of the broadcast (see below).
- bc_area: Message is sent to players in the vecinity of the source.
- bc_self: Message is sent only to current player.
You cannot use more than one target flag.

Source flags:
- bc_pc: Broadcast source is the attached player (default).
- bc_npc: Broadcast source is the NPC, not the player attached to the script
  (useful when a player is not attached or the message should be sent to those
  nearby the npc).
You cannot use more than one source flag.

Special flags:
- bc_yellow: Broadcast will be displayed in yellow color (default).
- bc_blue: Broadcast will be displayed in blue color.
- bc_woe: Indicates that this broadcast is 'WoE Information' that can be disabled client-side.
Due to the way client handles broadcasts, it is impossible to set both bc_blue and bc_woe.

The optional parameters allow usage of broadcasts in custom colors, font-weights, sizes etc.
If any of the optional parameters is used, special flag is ignored.
Optional parameters may not work well (or at all) depending on a game client used.

The color parameter is a single number which can be in hexadecimal notation.
For example:
    announce "This will be shown to everyone at all in green.",bc_all,0x00FF00;
Will display a global announce in green. The color format is in RGB (0xRRGGBB).

In official scripts only two font-weights (types) are used:
 - normal (FW_NORMAL = 400, default),
 - bold (FW_BOLD = 700).

Default font size is 12.

Using this for private messages to players is probably not that good an idea,
but it can be used instead in NPCs to "preview" an announce.

    // This will be a private message to the player using the NPC that made the 
    // announcement
    announce "This is my message just for you",bc_blue|bc_self;

    // This will be shown on everyones screen that is in sight of the NPC.
    announce "This is my message just for you people here",bc_npc|bc_area;

---------------------------------------

*mapannounce "<map name>","<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}}};

This command will work like 'announce' but will only broadcast to characters 
currently residing on the specified map. The flag and optional paramaters
parameters are the same as in 'announce', but target and source flags are ignored.

---------------------------------------

*areaannounce "<map name>",<x1>,<y1>,<x2>,<y2>,"<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}}};

This command works like 'announce' but will only broadcast to characters 
residing in the specified x1/y1-x2/y2 rectangle on the map given. The flags and
optional parameters are the same as in 'announce', but target and source flags are ignored.

    areaannounce "prt_church",0,0,350,350,"God's in his heaven, all right with the world",0;

---------------------------------------

*callshop "<name>",<option>;

These are a series of commands used to create dynamic shops. 
The callshop function calls a invisible shop (view -1) as if the player clicked on it.

For the options on callShop:
	0 = The normal window (buy, sell and cancel)
	1 = The buy window
	2 = The sell window
	
Example(s):

callshop "DaShop",1;	//Will call the shop named DaShop and opens the buy menu.

The shop which is called by callshop (as long as an npcshop* command is executed
from that NPC (see note 1)) will trigger the labels OnBuyItem and OnSellitem. These
labels can take over handling for relatively the buying of items from the shop 
and selling the items to a shop. Via these labels you can customize the way an item
is bought or sold by a player. 

In the OnBuyItem, two arrays are set (@bought_nameid and @bough_quantity), which
hold information about the name id (item id) sold and the amount sold of it. Same 
goes for the OnSellItem label, only the variables are named different 
(@sold_nameid and @sold_quantity). An example on a shop comes with eAthena, and 
can be found in the npc/sample/npc_dynamic_shop.txt file.
 
This example shows how to use the labels and their set variables to create a dynamic shop.

Note 1: These labels will only be triggered if a npcshop* command is executed, this is
because these commands set a special data on the shop npc,named master_nd in the source. 
The OnSellItem and OnBuyItem are triggered in the NPC whose master_nd is given in the shop.
This was found out thanks to 'Hondacrx', noticing the OnBuyItem wasn't triggered unless
npcshopitem was used. After rechecking the source, I found what caused this.

---------------------------------------

*npcshopitem "<name>",<item id>,<price>{,<item id>,<price>{,<item id>,<price>{,...}}}

This command lets you override the contents of an existing npc shop. The
current sell list will be wiped, and only the items specified with the price
specified will be for sale.

The function returns 1 if shop was updated successfully, or 0 if not found.

Note that you cannot use -1 to specify default selling price!

---------------------------------------

*npcshopadditem "<name>",<item id>,<price>{,<item id>,<price>{,<item id>,<price>{,...}}}

This command will add more items at the end of the selling list for the
specified npc shop. If you specify an item already for sell, that item will
appear twice on the sell list.

The function returns 1 if shop was updated successfully, or 0 if not found.

Note that you cannot use -1 to specify default selling price!

---------------------------------------

*npcshopdelitem "<name>",<item id>{,<item id>{,<item id>{,...}}}

This command will remove items from the specified npc shop.
If the item to remove exists more than once on the shop, all instances will be
removed.

Note that the function returns 1 even if no items were removed. The return
value is only to confirm that the shop was indeed found.

---------------------------------------

*npcshopattach "<name>"{,<标记>}

This command will attach the current script to the given npc shop.
When a script is attached to a shop, the events "OnBuyItem" and "OnSellItem"
of your script will be executed whenever a player buys/sells from the shop.
Additionally, the arrays @bought_nameid[], @bought_quantity[] or @sold_nameid[]
and @sold_quantity[] will be filled up with the items and quantities
bought/sold.

The optional parameter specifies whether to attach ("1") or detach ("0") from
the shop (the default is to attach). Note that detaching will detach any npc
attached to the shop, even if it's from another script, while attaching will
override any other script that may be already attached.

The function returns 0 if the shop was not found, 1 otherwise.

---------------------------------------

*waitingroom "<chatroom name>",<limit>{,<event label>,<trigger>,<required zeny>,<min lvl>,<max lvl>};

This command will create a chat room, owned by the NPC object running this 
script and displayed above the NPC sprite.
The maximum length of a chatroom name is 60 letters.

The limit is the maximum number of people allowed to enter the chat room. If the 
optional event and trigger parameters are given, the event label 
("<NPC object name>::<label name>") will be invoked as if with a 'doevent' upon 
the number of people in the chat room reaching the given triggering amount.

// The NPC will just show a box above its head that says "Hello World", clicking 
// it will do nothing, since the limit is zero.
    waitingroom "Hello World",0;

// The NPC will have a box above its head, it will say "Disco - Waiting Room" 
// and will have 8 waiting slots. Clicking this will enter the chat room, where 
// the player will be able to wait until 8 people accumulate. Once this happens, 
// it will cause the NPC "Bouncer" run the label "OnStart"

    waitingroom "Disco - Waiting Room",8,"Bouncer::OnStart",8;

// The NPC will have a box above its head, it will say "Party - Waiting Room"
// and will have 8 waiting slots. Clicking this will allow a player who has
// 5000 zeny and lvl 50~99 to enter the chat room, where the player will be
// able to wait until 8 people accumulate. Once this happens, it will cause
// the NPC "Bouncer" run the label "OnStart"

	waitingroom "Party - Waiting Room",5,"Bouncer::OnStart",8,5000,50,99;

Creating a waiting room does not stop the execution of the script and it will 
continue to the next line.

For more examples see the 2-1 and 2-2 job quest scripts which make extensive use 
of waiting rooms.

---------------------------------------

*delwaitingroom {"<NPC object name"};

This command will delete a waiting room. If no parameter is given, it will 
delete a waiting room attached to the NPC object running this command, if it is, 
it will delete a waiting room owned by another NPC object. This is the only way 
to get rid of a waiting room, nothing else will cause it to disappear.

It's not clear what happens to a waiting room if the NPC is disabled with 
'disablenpc', by the way.

---------------------------------------

*enablewaitingroomevent {"<NPC object name>"};
*disablewaitingroomevent {"<NPC object name>"};
*enablearena;
*disablearena;

This will enable and disable triggering the waiting room event (see 
'waitingroom') respectively. Optionally giving an NPC object name will do that 
for a specified NPC object. The chat room will not disappear when triggering is 
disabled and enabled in this manner and players will not be kicked out of it.
Enabling a chat room event will also cause it to immediately check whether the 
number of users in it exceeded the trigger amount and trigger the event 
accordingly.

Normally, whenever a waiting room was created to make sure that only one 
character is, for example, trying to pass a job quest trial, and no other 
characters are present in the room to mess up the script.

The 'enablearena'/'disablearena' commands are just aliases with no parameter.
These are supposedly left here for compatibility with official server scripts,
but no eathena script uses these at the moment.

---------------------------------------

*getwaitingroomstate(<information type>{,"<NPC object name>"})

This function will return information about the wating room state for the 
attached waiting room or for a waiting room attached to the specified NPC if 
any.

The valid information types are:

 0  - Number of users currently chatting.
 1  - Maximum number of users allowed.
 2  - Will return 1 if the waiting room has a trigger set.
      0 otherwise.
 3  - Will return 1 if the waiting room is currently disabled.
      0 otherwise.
 4  - The Title of the waiting room (string)
 5  - Password of the waiting room, if any. Pointless, since there is no way to 
      set a password on a waiting room right now.
 16 - Event name of the waiting room (string)
 32 - Whether or not the waiting room is full.
 33 - Whether the amount of users in the waiting room is higher than the trigger 
      number.

---------------------------------------

*getwaitingroommember "<NPC object name>"

该指令返回一个包含聊天室成员AID的数组$@waitingroommemberaid[]和一个聊天室成员数
的变量$@waitingroommembercount

---------------------------------------

*warpwaitingpc "<地图名>",<x>,<y>{,<number of people>};

This command will warp the amount of characters equal to the trigger number of 
the waiting room chat attached to the NPC object running this command to the 
specified map and coordinates, kicking them out of the chat. Those waiting the 
longest will get warped first. It can also do a random warp on the same map 
("Random" instead of map name) and warp to the save point ("SavePoint").

The list of characters to warp is taken from the list of the chat room members. 
Those not in the chat room will not be considered even if they are talking to 
the NPC in question. If the number of people is given, exactly this much people 
will be warped.

This command can also keep track of who just got warped. It does this by setting 
special variables:

$@warpwaitingpc[] is an array containing the character id numbers of the 
                  characters who were just warped.
$@warpwaitingpcnum contains the number of the character it just warped.

See also 'getpartymember' for advice on what to do with those variables.

The obvious way of using this effectively would be to set up a waiting room for 
two characters to be warped onto a random PVP map for a one-on-one duel, for 
example.

---------------------------------------

*kickwaitingroomall {"<NPC object name>"};

This command would kick everybody out of a specified waiting room chat. IF it 
was properly linked into the script interpreter which it isn't, even though the 
code for it is in place. Expect this to become available in upcoming SVN 
releases.

---------------------------------------

*setmapflagnosave "<地图名>","<alternate map name>",<x>,<y>;

This command sets the 'nosave' flag for the specified map and also gives an 
alternate respawn-upon-relogin point.

It does not make a map impossible to make a savepoint on as you would normally 
think, 'savepoint' will still work. It will, however, make the specified map 
kick the reconnecting players off to the alternate map given to the coordinates 
 specified.

---------------------------------------

*setmapflag "<地图名>",<标记>;

This command marks a specified map with a map flag given. Map flags alter the 
behavior of the map, you can see the list of the available ones in 
'db/const.txt' under 'mf_'.

The map flags alter the behavior of the map regarding teleporting (mf_nomemo, 
mf_noteleport, mf_nowarp, mf_nogo), storing location when disconnected 
(mf_nosave), dead branch usage (mf_nobranch), penalties upon death 
(mf_nopenalty, mf_nozenypenalty), PVP behavior (mf_pvp, mf_pvp_noparty, 
mf_pvp_noguild), WoE behavior (mf_gvg,mf_gvg_noparty), ability to use 
skills or open up trade deals (mf_notrade, mf_novending, mf_noskill, mf_noicewall),
current weather effects (mf_snow, mf_fog, mf_sakura, mf_leaves, mf_rain, mf_clouds, 
mf_fireworks) and whether night will be in effect on this map (mf_nightenabled).

---------------------------------------

*removemapflag "<map name>",<flag>;

This command removes a mapflag from a specified map. 
See 'setmapflag' for a list of mapflags.

---------------------------------------

*getmapflag("<map name>",<flag>)

This command checks the status of a given mapflag and returns the mapflag's state. 
0 means OFF, and 1 means ON. See 'setmapflag' for a list of mapflags.

---------------------------------------

*setbattleflag "<battle flag>",<value>;
*getbattleflag("<battle flag>")

Sets or gets the value of the given battle flag.
Battle flags are the flags found in the battle/*.conf files and is also used in Lupus' variable rates script.

Example(s):

//will set the base experience rate to 20x (2000%)
	setBattleFlag "base_exp_rate",2000;
	
//will return the value of the base experience rate (when used after the above example, it would return 2000).
	getBattleFlag "base_exp_rate";

---------------------------------------

*removemapflag "<地图名>",<标记>;

This command removes a mapflag from a specified map. See 'setmapflag'.

---------------------------------------

*warpportal <x>,<y>,"<mapname>",<x>,<y>;

Creates a warp Portal as if a acolyte class character did it.
The first x and y is the place of the warp portal on the map where the NPC is on
The mapname and second x and y is the target area of the warp portal.

Example(s):

//Will create a warp portal on the NPC's map at 150,150 leading to prontera, coords 150,180.
	warpPortal 150,150,"prontera",150,180;

---------------------------------------

*mapwarp "<from map>","<to map>",<x>,<y>;

This command will collect all characters located on the From map and warp them 
wholesale to the same point on the To map, or randomly distribute them there if 
the coordinates are zero. "Random" is understood as a special To map name and 
will mean randomly shuffling everyone on the same map.

---------------------------------------
\\
5,2.- Guild-related Commands
\\
---------------------------------------

*maprespawnguildid "<地图名>",<guild id>,<标记>;

This command goes through the specified map and for each player and monster 
found there does stuff.

Flag is a bitmask (add up numbers to get effects you want)
 1 - warp all guild members to their savepoints.
 2 - warp all non-guild members to their savepoints.
 4 - remove all monsters which are not guardian or emperium.

Flag 7 will, therefore, mean 'wipe all mobs but guardians and the emperium and 
kick all characters out', which is what the official scripts do upon castle 
surrender. Upon start of WoE, the scripts do 2 (warp all intruiders out).

Characters not belonging to any guild will warp out regardless of the flag setting.

For examples, check the WoE scripts in the distribution.

---------------------------------------

*agitstart;
*agitend;
*agitstart2;
*agitend2;

These two commands will start and end War of Emperium.

This is a bit more complex than it sounds, since the commands themselves won't 
actually do anything interesting, except causing all 'OnAgitStart:' and 
'OnAgitEnd:' events to run everywhere, respectively. They are used as 
simple triggers to run a lot of complex scripts all across the server, and they, 
in turn, are triggered by clock with an 'OnClock<time>:' time-triggering label.

---------------------------------------

*gvgon "<地图名>";
*gvgoff "<地图名>";

These commands will turn GVG mode for the specified maps on and off, setting up 
appropriate map flags. In GVG mode, maps behave as if during the time of WoE, 
even though WoE itself may or may not actually be in effect. 

---------------------------------------

*flagemblem <guild id>;

This command only works when run by the NPC objects which have sprite id 722, 
which is a 3D guild flag sprite. If it isn't, the data will change, but nothing 
will be seen by anyone. If it is invoked in that manner, the emblem of the 
specified guild will appear on the flag, though, if any players are watching it 
at this moment, they will not see the emblem change until they move out of sight 
of the flag and return.

This is commonly used in official guildwar scripts with a function call which 
returns a guild id:

// This will change the emblem on the flag to that of the guild that owns
// "guildcastle"

    flagemblem GetCastleData("guildcastle",1); 

---------------------------------------

*guardian("<地图名>",<x>,<y>,"<name to show>",<mob id>,<amount>{,"<event label>"}{,<guardian index>})

This command is roughly equivalent to 'monster', but is meant to be used with 
castle guardian monsters and will only work with them. It will set the guardian 
characteristics up according to the castle's investment values and otherwise 
set the things up that only castle guardians need.

Since trunk r12524:
Returns the id of the mob or 0 if an error occurred.
When 'guardian index' isn't supplied it produces a temporary guardian.
Temporary guardians are not saved with the castle and can't be accessed by guardianinfo.

---------------------------------------

*guardianinfo("<地图名>", <guardian number>, <类型>)

This function will return various info about the specified guardian, or -1
if it fails for some reason. It is primarily used in the castle manager npc.

Map name and guardian number (value between 0 and 7) define the target.
Type indicates what information to return:
 0 - visibility (whether the guardian is installed or not)
 1 - max. hp
 2 - current hp

---------------------------------------
//
5,2.- End of guild-related commands
//
---------------------------------------

*npcspeed <速度值>;
*npcwalkto <x>,<y>;
*npcstop;

These commands will make the NPC object in question move around the map. As they 
currently are, they are a bit buggy and are not useful for much more than making 
an NPC move randomly around the map. (see 'npc/custom/devnpc.txt' for an example 
of such usage)

'npcspeed' will set the NPCs walking speed to a specified value. As in the 
@speed GM command, 200 is the slowest possible speed while 0 is the fastest 
possible (instant motion). 100 is the default character walking speed.
'npcwalkto' will start the NPC sprite moving towards the specified coordinates 
on the same map as it is currently on.
'npcstop' will stop the motion.

While in transit, the NPC will be clickable, but invoking it will cause it to 
stop motion, which will make it's coordinates different from what the client 
computed based on the speed and motion coordinates. The effect is rather 
unnerving.

Only a few NPC sprites have walking animations, and those that do, do not get 
the animation invoked when moving the NPC, due to the problem in the npc walking 
code, which looks a bit silly. You might have better success by defining a job-
sprite based sprite id in 'db/mob-avail.txt' with this.

---------------------------------------

*movenpc <NPC名>,x,y{,dir};
	作用：移动NPC到指定坐标(x,y)
	举例：
		moveNPC "Bugga",100,20;
	
---------------------------------------

=====================
|6.- 其他命令.      |
=====================
---------------------------------------

*debugmes "<信息>";

该命令会发送信息至服务器控制台 (地图服务器窗口). 除此之外没有地方会显示.

    debugmes strcharinfo(0)+" 做了xxx";
    // 你可以在地图服务器窗口里看到 "NAME 做了xxx"

---------------------------------------

*logmes "<信息>";

该命令会把信息写入地图服务器的记录文件(在'conf/log_athena.conf'设置的). 
在TXT版本中, 默认记录文件是 'log/npclog.log'. 
在SQL版本中, 如果记录功能打开, 信息会存入npclog表, 否则同TXT.

如果记录功能没有打开, 则什么都不会发生.

---------------------------------------

*globalmes "<信息>"{,"<NPC名>"};

该命令会发送信息至所有连接玩家的聊天窗口.

如果指定了NPC名字, 信息就会像是NPC说的话那样显示.

---------------------------------------

*rand(<数字>{,<数字>});

如果你只指定了一个数,该命令会返回0 - 你指定数之间的一个随机数.
如果你指定2个数,则返回你指定2个数之间的一个随机数.

rand(10) 的结果会是 0,1,2,3,4,5,6,7,8 or 9

rand(2,10) 的结果会是 2,3,4,5,6,7,8,9 or 10

---------------------------------------

*viewpoint <动作>,<x>,<y>,<点数量>,<颜色>;

该地图会在连接的玩家的客户端的小地图上做标记。它是用地图上的x、y坐标。
颜色有十六进制数字决定, 和mes命令用的一样。
(看上去像 0x<6位数字>.)

动作是你要对点进行的操作, 1是设置, 2是清除。多个点在同一坐标可以用来创建闪光点。

    // 该命令会在坐标 X 30 Y 40 坐标记, 
    // 并且是红色的.
    
    viewpoint 1,30,40,1,0xFF0000;

这会创建3个点:

    viewpoint 1,30,40,1,0xFF0000;
    viewpoint 1,35,45,2,0xFF0000;
    viewpoint 1,40,50,3,0xFF0000;

这是如何清除他们:

    viewpoint 2,30,40,1,0xFF0000;
    viewpoint 2,35,45,2,0xFF0000;
    viewpoint 2,40,50,3,0xFF0000;
    
客户端储存所有信息，而服务器端不会。

---------------------------------------

*cutin "<文件名>",<位置>;

该命令会显示GRF文件中储存的图片。

文件取自文件夹 '\data\texture\蜡历牢磐其捞胶\illust' . 而且似乎卡片大图 \cardbmp 
也能正常工作。只有位图能显示。.bmp后缀不一定需要。

客户端对显示4096x4096的图片时没有问题的，但通常情况下只显示500x500. 颜色 FF00FF
当作透明色。

位置表示在屏幕上显示图片的位置:
  0 - 左下角
  1 - 下中
  2 - 右下角
  3 - 有标题栏，可移动，居中
  4 - 没有标题栏，可移动，居中
  255 - 去除所有图片
 
文件名留空而位置255将移除所有图片。其他位置数字不会使脚本出错，但会使客户端出错。
一个屏幕只能显示一张图片。

    // 这个会显示第七个卡普拉
    // 橙色迷你裙的那个
    cutin "kafra_7",2;

    // 去除显示的图片
    cutin "Kafra_7",255;

    // 去除所有显示的图片
    cutin "",255;

---------------------------------------

*pet <宠物>;

捕捉宠物用，可以在道具脚本外使用。

可捕捉宠物ID见 'db/pet_db.txt'

---------------------------------------

*emotion <表情数字>{,<目标>{,"<目标名字>"}};

显示表情. 表情数字见 'db/const.txt' 以 'e_' 开头的. 

目标为0或省略则表情显示在NPC头上，目标为1则显示在关联玩家头上

<目标名字> 可以在其他没有事件标签的NPC/PC身上执行此指令。如果没有
发现名字则什么都不会做。

---------------------------------------

*misceffect <效果编号>;

如果运行该命令的NPC有显示，则效果会显示在该NPC头上. 否则则会显示在关联玩家身上. 
如果是道具脚本则会显示在玩家头上。

详细效果见 'doc/effect_list.txt'.

---------------------------------------

*soundeffect "<文件名>",<类型>
*soundeffectall "<文件名>",<类型>{,"<地图名>"}{,<x0>,<y0>,<x1>,<y1>}

在关联玩家客户端播放音乐 ('soundeffect') 或在指定区域的玩家客户端播放音乐
 ('soundeffectall'). 如果没有指定区域，则会在关联玩家身上播放，如果没有关联
玩家，则关联NPC。

类型不清楚，可能是文件夹的名字。0是'data/wav',而其他数字就不知道了。

---------------------------------------

*playBGM "<背景音乐文件名>"
*playBGMall "<背景音乐文件名>",{,"<地图名>"}{,<x0>,<y0>,<x1>,<y1>}

这两条指令会对关联角色('playBGM')或多个角色('playBGMall')播放背景音乐。
如果由浮动NPC运行此指令或者不是由NPC(道具脚本)运行此指令，声音会从关联
脚本的角色(如果有的话)为中心发出。除此之外，都会以NPC为中心发出。

背景音乐文件名是在/BGM/文件夹中的文件名. 必须以.mp3为扩展名。

脚本无需指定扩展名。
如果坐标被省略，则全地图播放。

通常情况下，你可以这样自定义背景音乐。

---------------------------------------

*pvpon "<地图名>";
*pvpoff "<地图名>";

为指定地图打开PVP模式。效果同@pvpon。

---------------------------------------

*atcommand "<command line>",<标记>;

这条命令会运行制定命令，就好像是99级的GM在键盘上输入一样。

	// 无条件杀死该玩家
	input @player$;
	atcommand "@nuke "+@player$;

使用标记后，将使用静默默示，不会显示平时使用指令时的信息。

	//将不会给玩家显示"人物光环已显示。"
	atcommand "@aura 675",1;

---------------------------------------

*charcommand <command>,<标记>;

根据Lance所说该命令无需玩家关联。

举例：
	charCommand "#option 0 0 0 Roy";

---------------------------------------

*unitskilluseid <GID>,<技能id>,<技能等级>;
*unitskillusepos <GID>,<技能id>,<技能等级>,<x>,<y>;

这是用来代替旧命令的, GID和unit系列命令用的一样。

x，y是地图坐标。

---------------------------------------

*day;
*night;

这两天命令将实现服务器的昼夜交替。
设置不同会有不同的客户端效果。如果服务器设置成了昼夜交替，最终会返回那个轮回。

这个例子讲把早上3点设置成晚上而8点天亮, 而如果自动黑夜白昼切换在设置中关闭，
服务器在黑夜期间重启，则黑夜效果将持续。自己理解吧：

-%TAB%script%TAB%DayNight%TAB%-1,{
        
	end;

OnClock0300:
    
OnClock0800:
    
OnInit:

        set $@minutesfrommidnight, gettime(3)*60+gettime(2);

        set $@night_start, 180; // 03:00
        set $@night_end, 480;   // 08:00

        if ($@minutesfrommidnight>=$@night_start && $@minutesfrommidnight<$@night_end) goto StartNight;

        goto StartDay;
	StartNight:	
	night;
	end;
	StartDay:
	day;
	end;	} 

---------------------------------------

*defpattern <设置编号>,"<常规表达模板>","<事件标签>";
*activatepset <设置编号>;
*deactivatepset <设置编号>;
*deletepset <设置编号>;

这套命令仅在服务器支持常规表达库时有效. 不幸的是, 默认编译是不支持的, 但这些
随便使用困难, 但效果很奇特.

NPC会监听玩家的公开对话, 如果符合常规表达模板, 就会触发事件.

模板按设置编号分类. 可以设置并激活多个模板. 模板编号从1开始.

'defpattern' 会关联表达式和事件. 如果模板激活而又玩家说的话符合模板内容, 则事
件就会触发.

'activatepset' 可以激活指定编号的模板. 激活的模板可以通过 'defpattern' 触发事
件, 模板默认不激活.
'deactivatepset' 可以取消激活指定编号的模板. 如果指定模板编号为 -1,则所有模板
都取消激活.

'deletepset' 会从内存中删除指定编号的模板, 你可以重新设置该编号的模板.

使用常规表达式会有很不可思议的效果. 而这不可思议的效果同样伴随着其独特的文本
控制能力. 要更多常规表达式的解释, 请参阅:

http://www.regular-expressions.info/
http://www.weitz.de/regex-coach/

使用举例, 见 'npc\sample\npc_pcre.txt'.

通过这些你可以对当众乞讨的玩家进行惩罚,或者反过来,你也可以直接给他钱.

---------------------------------------

*pow(<数字>,<幂>)

返回计算结果

举例:
set @i, pow(2,3); // @i 是 8

---------------------------------------

*sqrt(<数字>)

返回开方值

举例:
set @i, sqrt(25); // @i 是 5

---------------------------------------

*distance(<x0>,<y0>,<x1>,<y1>)

返回两点间的距离

举例:
set @i, distance(100,200,101,202);

---------------------------------------

*md5("<string>")

Returns the md5 checksum of a number or string.

Example:
	mes md5(12345);
	mes md5("12345"); 	// Will both display 827ccb0eea8a706c4c34a16891f84e7b
	mes md5("qwerty"); 	// Will display d8578edf8458ce06fbc5bb76a58c5ca4

---------------------------------------

*query_sql "MySQL语句", <数列名>{,<数列名>{;

最大返回 127 个值至数列.

举例:
set @nb, query_sql("select name,fame from `char` ORDER BY fame DESC LIMIT 5", @name$, @fame);
mes "名誉大厅: 前五";
mes "1."+@name$[0]+"("+@fame[0]+")"; // 返回名誉最大值的人
mes "2."+@name$[1]+"("+@fame[1]+")";
mes "3."+@name$[2]+"("+@fame[2]+")";
mes "4."+@name$[3]+"("+@fame[3]+")";
mes "5."+@name$[4]+"("+@fame[4]+")";

注意: TXT版本无效,并将返回-1.
注意: 使用 $ 作为前缀来获得字符数据.

---------------------------------------

*escape_sql("<string>")

Escapes special characters in the string, so that it is safe to use in query_sql(), 
and returns the escaped form of the given string.

Example 1:
	set .@str$, "John's Laptop";
	set .@esc_str$, escape_sql(.@name$);	// Escaped string: John\'s Laptop

---------------------------------------

*setiteminfo(<item id>,<type>,<value>) 
 
This function will set some value of an item. 
Returns the new value on success, or -1 on fail (item_id not found or invalid type). 

Valid types are: 
 	0 - Buy Price; 1 - Sell Price; 2 - Item Type; 
	3 - maxchance (Max drop chance of this item e.g. 1 = 0.01% , etc.. 
	    if = 0, then monsters don't drop it at all (rare or a quest item) 
	    if = 10000, then this item is sold in NPC shops only 
	4 - sex; 5 - equip; 6 - weight; 7 - atk; 8 - def; 9 - range; 
	10 - slot; 11 - look; 12 - elv; 13 - wlv; 14 - view id 

Example: 

setiteminfo 7049,6,999; // Stone now weighs 999 
	
--------------------------------------- 

*setitemscript(<道具ID>,<"{ 新道具脚本 }">);

为道具设置新的脚力语句. 对游戏活动很有用.
可以通过留空来去除道具效果.
You can remove an item's itemscript by leaving the itemscript argument empty.
Type can optionally be used indicates which script to set (default is 0):
 0 - Script
 1 - OnEquip_Script
 2 - OnUnequip_Script

举例:

setitemscript 2637,"{ if(isequipped(2236)==0)end; if(getskilllv(26)){skill 40,1;}else{skill 26,1+isequipped(2636);} }";
setitemscript 2637,"";

---------------------------------------

*atoi ("<字符串>")
*axtoi ("<字符串>")

此类命令用来转换字符串为数字 
atoi 转换十进制数字而 axtoi 转换十六进制.

举例:

	mes atoi("11"); 		// 将显示 11 
	set @var, axtoi("FF");		// 将把 @var 设置为 255
	mes axtoi("11"); 		// 将显示 17 (1 = 1, 10 = 16, 
					// 十六进制: {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F})

---------------------------------------

*compare (<字符串>,<子字符串>)

如果子字符串包含在字符串中,该函数返回1,否则返回0.
该命令不区分大小写.

举例:

//dothis; will be executed ('Bloody Murderer' contains 'Blood').
	if (compare("Bloody Murderer","Blood"))
		dothis;
//dothat; will not be executed ('Blood butterfly' does not contain 'Bloody').
	if (compare("Blood Butterfly","Bloody"))
		dothat;

---------------------------------------

*charisalpha("<字符串>",<位置>)

如果字符串的指定位置是字母, 该函数会返回 1 , 如果是数字或空格会返回0.

---------------------------------------

*wedding_effect;
结婚成功是播放结婚效果 (音乐等)
结婚脚本中有实例.

---------------------------------------

*setfont <字体>
This command sets the current RO client interface font to one of the
fonts stored in data\*.eot by using an ID of the font. When the ID
of the currently used font is used, default interface font is used again.
     0 - Default
     1 - RixLoveangel
     2 - RixSquirrel
     3 - NHCgogo
     4 - RixDiary
     5 - RixMiniHeart
     6 - RixFreshman
     7 - RixKid 
     8 - RixMagic
     9 - RixJJangu 

--------------------------------------

* 宠物AI命令

这些命令仅在关联人物有宠物的情况下才能工作，并且理论上只有在宠物脚本里才有效。
这些命令会改变关联人物的宠物AI，而他们自己是不会独立工作的，这也是为什么只有
一条命令有效。一个宠物可以同时有'petloot', 'petskillbonus', 'petskillattack' 或
'petpetskillattack2' 和 'petskillsupport' 或 'petheal'。 'petheal' 在默认宠物脚
本里不再使用。

*petskillbonus <奖励类型>,<值>,<持续时间>,<延时>;

让宠物给主人属性点奖励 (奖励类型 - bInt,bVit,bDex,bAgi,bLuk,bStr,bSpeedRate - 
详见'db/const.txt'的b开头部分)

*petrecovery <属性类型>,<延时>;

让宠物治愈指定的状态。治愈效果会在每次延时的间隔时间内发生。
详见'db/const.txt'的SC_开头部分

*petloot <最大数量>;

该命令会开启宠物的拾取功能。
宠物会在最大数量到达的时候或在表现状态的时候把储存的物品放出。

*petskillsupport <技能id>,<技能等级>,<延时>,<hp百分比>,<sp百分比>;
*petskillsupport "<技能名>",<技能等级>,<延时>,<hp百分比>,<sp百分比>;

该命名会使宠物在主人的hp或sp在指定的百分比以下时，根据指定延时，对主人使用支持技能。
技能id见'db/skill_db.txt'.

*petskillattack <技能id>,<技能等级>,<几率>,<奖励几率>;
*petskillattack "<技能名>",<技能等级>,<几率>,<奖励几率>;
*petskillattack2 <技能id>,<伤害>,<攻击次数>,<几率>,<奖励几率>;
*petskillattack2 "<技能名>",<伤害>,<攻击次数>,<几率>,<奖励几率>;

这两条命令会让宠物对主人当前攻击的敌人咏唱攻击技能。技能id和等级与'petskillsupport'
相同。'petskillattack2'会让宠物使用的技能使用修正的伤害值和指定的攻击次数。

几率是发动效果的百分率。 'bonusrate'是当宠物亲密度达到最大值时，在普通几率上增长的
几率。

上述效果只有在宠物足够亲密，并且在'battle_athena.conf'中进行了正确设置后才有效。

宠物脚本在宠物孵化的时候就会运行。item脚本里的命令在此时也能运行。显然，宠物命令在
npc脚本里也有效，直到宠物被再次孵化（人物上下线后也会失效）。NPC脚本生效的宠物AI的
持续时间尚不清楚，但至少，这可以用来制作为对宠物进行BUFF的道具。

--------------------------------------

*bpet;

在当前人物的客户端内打开宠物孵化窗口。
可以在道具脚本外使用。

---------------------------------------

*makepet <pet id>;

此命令会创建一个宠物蛋放在关联人物的道具栏内。宠物类型由'db/pet_db.txt'内的宠物
ID决定。创建宠物蛋和玩家成功捕捉魔物的方式一模一样。

    // 给你一个波利:
    makepet 1002;

注意你不需用此方法创建宠物蛋。如果你用getitem来创建宠物蛋，那么宠物蛋数据不会传
递给人物服务器，而玩家在孵化宠物的时候，蛋就会直接消失。(Inkfish: 貌似现在不会消失)

---------------------------------------

*openmail;

打开关联人物的邮箱窗口。

    mes "关闭此窗口来打开邮箱窗口。";
    close2;
    openmail;
    end;

---------------------------------------

*homshuffle;

按照生命体当前等级重新计算当前关联人物的生命体属性。

---------------------------------------

*setcell "<地图名>",<x1>,<y1>,<x2>,<y2>,<类型>,<标记>;

每个地图的单元格都有很多指定其单元格属性的“标记”。
包括地形属性 (能否行走, 能否攻击, 是否存在水),
技能 (神圣殿堂, 地属性领域, ...) 和其他 (npc附近, 禁止交易, ...).
每种类型都能打开或关闭。他们共同决定了此单元格的表现。

该命令能让你转换指定坐标范围内(x1,y1)-(x2,y2)的所有地图单元格的标记状态。
标记可以是0或1 (0:清除标记, 1:设置标记).
类型定义了要标记的内容。有效类型包括：cell_walkable,
cell_shootable, cell_basilica. 详见const.txt.

举例:

	setcell "arena",0,0,300,300,cell_basilica,1;
	setcell "arena",140,140,160,160,cell_basilica,0;
	setcell "arena",135,135,165,165,cell_walkable,0;
	setcell "arena",140,140,160,160,cell_walkable,1;

这会在地图中央创建一个圆。圆外有一个5格宽的圆环，防止与外界交流。地图的其余
部分被标记为“神圣殿堂”，禁止任何人的攻击。客户端不会显示圆环为墙，但却不能移动

再举例:

OnBarricadeDeploy:
	setcell "schg_cas05",114,51,125,51,cell_walkable,0;
	end;
OnBarricadeBreak:
	setcell "schg_cas05",114,51,125,51,cell_walkable,1;
	end;

这是WoE:SE的一部分脚本, 攻击者在路障被清除前无法继续前进。这条命令会创建一条不
能行走的单元格，并在路障被清除后取消。
	
---------------------------------------

*checkcell ("<地图名>",<x>,<y>,<类型>);

该命令会返回 1 或 0, 取决于指定单元格是否设置了指定“类型”。有很多类型可以
检测, 所有类型参见db/const.txt。

有些类型容易混淆, 下面作一下解释:
  - cell_chkwall/water/cliff
    这些直接对指定单元格的“地形”作检查
  - cell_chkpass/reach/nopass/noreach
    passable = 不是墙也不是断头路, reachable = 可通过但不能重叠
  - cell_chknpc/basilica/landprotector/novending/nochat
    他们的名字就似乎他们的意思（npc、神圣殿堂、地属性领域、不能开商店、不能开聊天室）

举例:

	mes "挑一个目标地图";
	input .@map$;
	mes "好，再给我坐标";
	input .@x;
	input .@y;
	if( !checkcell(.@map$,.@x,.@y,cell_chkpass) )
	{
		mes "抱歉，不能把你传送过去!";
		close;
	}
	else
	{
		mes "好吧，准备好了...";
		close2;
		warp .@map$, .@x, .@y;
		end;
	}

---------------------------------------
*setwall "<地图名>",<x>,<y>,<大小>,<方向>,<可远程攻击>,"<名称>";  
*delwall "<名称>";  

创建一个无形的墙，从指定坐标、在指定方向建立一排指定大小的单元。与setcell的不
同点在于，此命令同时更新客户端部分，以防出错。

--------------------------------------- 

*progressbar "<颜色>",<时间>;  

时间为秒，颜色暂无意义。

在人物头上显示进度条。

例如：
	progressbar 0x000000,10;
	mes "你好";
	close;
客户端将显示一个10秒的进度条，然后显示“你好”。
进度条进行中时，无法使用技能；移动将取消进度条，终结脚本。

--------------------------------------- 

*questnotify <类型1>, <类型2>;
*showevent <类型1>, <类型2>;

显示NPC坐标在小地图中，并在NPC头上显示表情。

type1:
	0 = 取消表情和标记
	1 = 感叹号表情
	2 = 问号表情

type2:
	0 = 黄色标记, 表情显示"quest"
	1 = 橙色标记, 表情显示"job"
	2 = 绿色标记, 表情显示"event"
	3 = 蓝色标记, 没有表情，只有横幅显示MVP

----------------------------------------

========================
|7.- 副本系统指令.|
========================
---------------------------------------

*instance_create("<副本名>",<队伍ID>)

以副本名 "<副本名>" 为队伍ID为 <队伍 ID>的队伍创建副本.
Most Instance_* commands are used in conjunction with this command and depend
on the ID this command returns.

Example: 
	// Store the Party ID of the invoking character.
	set .@party_id, getcharid(1);
	// Atempt to create an instance using that party ID.
	set .@id, instance_create("Endless Tower", .@party_id);
	if (.@id == -1) { // Party ID is in use by another instance.
		...
	}
	else (.@id < 0) { // Unspecified error while queuing instance.
		...
	}
---------------------------------------

*instance_destroy({<副本 ID>})

销毁ID为 <副本 ID> 的副本.
如果没有指定id，该脚本关联的副本id会被使用。
如果脚本没有关联副本，关联该脚本的玩家所关联的副本id会被使用。
如果玩家也没有关联副本，那么指令执行失败，脚本终止。

---------------------------------------

*instance_attachmap(<副本 ID>,"<地图名>"{,<使用基本地图名>})

关联地图名为 "<Map Name>" 到id为 <副本 ID>的副本.The
 
The optional parameter specifies, whether a map requires emulation for instancing (1)
or not (0 = default).

返回地图名。

---------------------------------------

*instance_detachmap("<地图名>"{,<副本id>})

解除关联地图名为 "<Map Name>" 到id为 <副本 ID>的副本.
如果没有指定id，该脚本关联的副本id会被使用。
如果脚本没有关联副本，关联该脚本的玩家所关联的副本id会被使用。
如果玩家也没有关联副本，那么指令执行失败，脚本终止。

---------------------------------------

*instance_init(<副本 ID>);

初始化id为 <副本 ID> 的副本.

---------------------------------------

*instance_announce <副本 ID>,"<文本>",<标签>{,<颜色>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}};;

像announce指令一样, 但拥有参数 <副本 ID> , 当值为 0 时为所有激活副本？

---------------------------------------

*instance_attach(<副本 ID>);

将脚本关联到id为 <副本 ID> 的副本？

---------------------------------------

*instance_npcname("<NPC Name>"{,<副本 ID>})

获取副本中被复制的npc的唯一名.
给与的 "<NPC Name>" 属于id为 <副本 ID> 的副本. 
可以使用此命令来 enablenpc, disablenpc, donpcevent, 等等.
如果没有指定id，该脚本关联的副本id会被使用。
如果脚本没有关联副本，关联该脚本的玩家所关联的副本id会被使用。
如果玩家也没有关联副本，那么指令执行失败，脚本终止。

---------------------------------------

*has_instance("<Map Name>"{,<副本 ID>})

检查玩家是否在地图 <Map Name> 上有副本.
如果没有指定id，该脚本关联的副本id会被使用。
如果脚本没有关联副本，关联该脚本的玩家所关联的副本id会被使用。
如果玩家也没有关联副本，那么指令执行失败，脚本终止。

---------------------------------------

*instance_id(<type>)

返回当前玩家关联的副本id

type：
	0 - Instance ID the script is attached to.
	1 - Instance ID of the currently attached player's party.

---------------------------------------

*instance_warpall "<Map Name>",<x>,<y>{,<instance id>};

传送所有在副本中的玩家到地图 <map name> 的指定坐标.
如果没有指定id，该脚本关联的副本id会被使用。
如果脚本没有关联副本，关联该脚本的玩家所关联的副本id会被使用。
如果玩家也没有关联副本，那么指令执行失败，脚本终止。

---------------------------------------

*instance_set_timeout <Time1>,<Time2>{,<Instance ID>};

<Time1> 为副本 <副本 ID> 的存在时间, <Time2> 是冷却时间
如果没有指定id，该脚本关联的副本id会被使用。
如果脚本没有关联副本，关联该脚本的玩家所关联的副本id会被使用。
如果玩家也没有关联副本，那么指令执行失败，脚本终止。

---------------------------------------

========================
|8.- Quest Log commands.|
========================
---------------------------------------

*setquest <ID>;

获取任务DB中对应<ID>的任务到玩家任务记录中,状态为激活.

---------------------------------------

*completequest <ID>;

完成任务DB中对应<ID>的任务,并玩家任务记录中删除.

---------------------------------------

*erasequest <ID>;

删除任务DB中对应<ID>的任务

---------------------------------------

*changequest <ID>,<ID2>;

删除任务DB中对应<ID>的任务
获取任务DB中对应<ID2>的任务到玩家任务记录中,状态为激活.

---------------------------------------

checkquest(<ID>{,PLAYTIME|HUNTING});

没有附加参数时:
	-1 = 未获得任务
	0  = 任务未激活
	1  = 任务激活
	2  = 任务完成
	
参数PLAYTIME:
	-1 = 未获得任务
	0  = 时限未到
	1  = 时限未到且任务已经完成
	2  = 时限已到
	
参数HUNTING:
	-1 = 未获得任务
	0  = 未杀完魔物但时间未到
	1  = 未杀完魔物但时间已到
	2  = 杀完魔物

---------------------------------------

===========================
|9.- 战场指令.|
===========================
---------------------------------------

*waitingroom2bg_single(<battle group>,"<mapname>",<x>,<y>,"<npc name>");

Adds the first waiting player from the chat room of given NPC to an
existing battleground group and warps it to specified coordinates on
given map.

---------------------------------------

*waitingroom2bg("<mapname>",<x>,<y>,"<On Quit Event>","<On Death Event>"{,"<npc name>"});

<Mapname> and X Y coordinates refer to where the "respawn" base is, where the player group will respawn when they die.
<On Quit Event> refers to an NPC label that attaches to the character and is run when they relog.
<On Death Event> refers to an NPC label that attaches to the character and is run when they die. Can be "" for empty.

Unlike the prior command, the latter will attach a GROUP in a waiting room to the battleground, and 
sets the array $@arenamembers[0] where 0 holds the IDs of the first group, and 1 holds the IDs of the second.

If the option parameter is left out, the waiting room of the current NPC is used.

Example:
	// Battle Group will be referred to as $@KvM01BG_id1, and when they die, respawn at bat_c01,52,129.
	set $@KvM01BG_id1, waitingroom2bg("bat_c01",52,129,"KvM01_BG::OnGuillaumeQuit","KvM01_BG::OnGuillaumeDie");
	end;

----------------------------------------

*bg_team_setxy <Battle Group ID>,<x>,<y>;

Update the respawn point of the given battle group to x, y on the same map. The <Battle Group ID> can be retrieved using getcharid(4)

Example:
	bg_team_setxy getcharid(4),56,212;
	mapannounce "bat_a01", "Group [1] has taken the work shop, and will now respawn there.",bc_map,"0xFFCE00";
	end;

----------------------------------------

*bg_warp <Battle Group>,"<Mapname>",<x>,<y>;

Similar to warp command.
Place all members of <Battle Group> at <mapname> at x y.

Example:
	//place the battle group one for Tierra Gorge at starting position.
	bg_warp $@TierraBG1_id1,"bat_a01",352,342;
	end;

----------------------------------------

*bg_monster <Battle Group>,"<map name>",<x>,<y>,"<name to show>",<mob id>,"<event label>";
*bg_monster(<Battle Group>,"<map name>",<x>,<y>,"<name to show>",<mob id>,"<event label>");

Similar to monster script command.
Spawn a monster with allegiance to the given battle group.
Does not allow for the summoning of multiple monsters.
Monsters are similar to that in War of Emperium, in that the specified Battle group is considered friendly.

Example:
	// It can be used in two different ways.
	bg_monster $@TierraBG1_id2,"bat_a01",167,50,"Food Depot",1910,"Feed Depot#1::OnMyMobDead";
	end;

	// Alternatively, you can set an ID for the monster using "set".
	// This becomes useful when used with the command below.
	set $@Guardian_3, bg_monster($@TierraBG1_id2,"bat_a01",268,204,"Guardian",1949,"NPCNAME::OnMyMobDead");
	end;

----------------------------------------

*bg_monster_set_team <GID>,<Battle Group>;

This command will change the allegiance if a monster in a battle ground.
GID can be set when spawning the monster via the bg_monster command.

Example:

	end;

OnEnable:
	mapannounce "A guardian has been summoned for Battle Group 2!",bc_map,"0xFFCE00";
	set $@Guardian, bg_monster($@BG_2,"bat_a01",268,204,"Guardian",1949,"NPCNAME::OnMyMobDead");
	initnpctimer;
	end;

OnTimer1000:
	stopnpctimer;
	mapannounce "Erm, sorry about that! This monster was meant for Battle Group 1.",bc_map,"0xFFCE00";
	bg_monster_set_team $@Guardian, $@BG_1;
	end;

----------------------------------------

*bg_leave;

Removes attached player from their Battle Group.

----------------------------------------

*bg_destroy <Batte Group>;

As the name says, destroys the battle group created for that battle ground.

----------------------------------------

*areapercentheal "<mapname>",<x1>,<y1>,<x2>,<y2>,<hp>,<sp>;

Not exactly limited to battleground use, this will restore HP/SP in a defined area at a percentage.

Example:
	areapercentheal "bat_a01",52,208,61,217,100,100;
	end;

----------------------------------------

*bg_get_data(<Battle Group>,<type>);

Retrieves data related to given battle group. Type can be one of the following:

    0 - Amount of players currently belonging to the group.

----------------------------------------

*bg_getareausers(<battle group>,<map name>,<x0>,<y0>,<x1>,<y1>);

Retrieves amount of players belonging to given battle group on given
map within an specified rectangular area.

----------------------------------------

*bg_updatescore "<mapname>",<Guillaume Score>,<Croix Score>;

Only usable when the map is defined as type:
mapflag	<mapname>	battleground	2
This command will force the update of the displayed scoreboard.

----------------------------------------

bg_kickall <battleground ID>;

----------------------------------------

getbgusers <battleground ID>;

----------------------------------------

setbgid <battleground ID> {, <player name> };

----------------------------------------

createbgid <battleground ID>, <respawn map>, <respawn x>, <respawn y>, <On Quit event>, <On Death event>;

----------------------------------------

==========================
|10.- Mercenary commands.|
==========================
---------------------------------------

*mercenary_create <class>,<contract time>;

This command summons a mercenary of given class, for given amount of
time in milliseconds. Typically used in item scripts of mercenary
scrolls.

----------------------------------------

*mercenary_heal <hp>,<sp>;

This command works like 'heal', but affects the mercenary of the
currently attached character.

----------------------------------------

*mercenary_sc_start <type>,<tick>,<val1>;

This command works like 'sc_start', but affects the mercenary of the
currently attached character.

----------------------------------------

*mercenary_get_calls(<guild>);
*mercenary_set_calls <guild>,<value>;

Sets or gets the mercenary calls value for given guild for currently
attached character. Guild can be one or the following constants:

    ARCH_MERC_GUILD
    SPEAR_MERC_GUILD
    SWORD_MERC_GUILD

----------------------------------------

*mercenary_get_faith(<guild>);
*mercenary_set_faith <guild>,<value>;

Sets or gets the mercenary faith value for given guild for currently
attached character. Guild can be one or the following constants:

    ARCH_MERC_GUILD
    SPEAR_MERC_GUILD
    SWORD_MERC_GUILD

---------------------------------------

========================
|11.- SeA 指令|
========================
---------------------------------------

*getnpcdata("类型"{,<NPCID>/"NPC名"});
*setnpcdata <类型>,"值"{,<NPCID>/"NPC名"};
	类型：	  1： NPC 名，2： NPC大小(0,1,2)，3： NPC方向(0~7)
		  10：形象ID，11：头上饰品，      12：头中饰品，   13：头下饰品
		  14：性别，  15：发型，          16：发色，       17：衣服色
	特殊类型：0： 仅对getnpcdata有作用，返回NPCID
		  20：仅对setnpcdata有作用，复制指定CID的人物形象给npc。
	举例：
		getnpcdata(1);			//返回npc名
		setnpcdata 20,getcharid(0);	//复制自己的形象给npc
	注：	仅Xray客户端支持NPC使用玩家形象。

---------------------------------------

*dupnpc "参数1","参数2","参数3","参数4";
	作用：	复制NPC。
	举例:
		脚本:
		prontera,146,99,2	script	PVP服务::PVP	917,{
			end;
		}

		通常复制语句:
		prontera,156,99,2	duplicate(PVP)	PVP服务#1	917

		该命令语法:
		dupnpc "prontera,156,99,2","duplicate(PVP)","PVP服务#1","917";

		即，所有<%TAB>用逗号代替，每个参数之间加引号。

---------------------------------------

*mobuseskill <GID>,"技能名"/<技能id>,<技能等级>,<咏唱时间>,<可否中断咏唱>,<表情>,<目标类型>;
	作用：	指定魔物使用某技能。
	目标类型:	0:自己
			1:攻击对象
			2:主人
			其他值:随机。

---------------------------------------

*enhance <装备位置>, <类型>, <数值>;
	作用：	增加或减少或查询某位置装备的耐久度。
		装备不存在时返回-1，否则返回物品的耐久度。
		<类型>为0时调整当前耐久度，<类型>为1时调整最大耐久度。
		<数值>为0时即查询耐久度。

---------------------------------------

*getdurequip <道具id或道具名>,<精炼值>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<最大耐久度>{,<角色ID>};
	作用：	得到有耐久度的指定道具。
	例如：	getdurequip 2424,10,0,0,0,0,200; 玩家将得到200耐久度的+10轻便鞋。

---------------------------------------

*getnpcid({"<npcname>"});
	作用：	返回npc id，不输入名字则返回当前npc id；否则则返回输入名字之npc id。
		npc有唯一名(::Name)则输入唯一名；否则，如果有隐藏名则输入显示名+隐藏名，
		没有隐藏名则输入显示名。

---------------------------------------

*delinventory <位置序号>,<数量>;
	作用：	删除道具栏中某位置的物品，位置序号通过getinventoryinfo比对确认。

---------------------------------------

*equipinventory <位置序号>;
	作用：	装备道具栏中某位置的物品，位置序号通过getinventoryinfo比对确认。

---------------------------------------

*getinventoryinfo(<位置序号>,  <类型>);
	作用：	根据物品栏位置编号查询物品信息。
		返回-1，如果物品不存在或类型不正确。
		类型：
		0:	id
		1:	数量
		2:	是否装备
		3:	精炼值
		4:	是否鉴定
		5:	是否损坏
		6:	卡片1
		7:	卡片2
		8:	卡片3
		9:	卡片4
		10:	租赁到期时间
		11:	耐久度修复后可以使用的时间
		12:	当前耐久度
		13:	耐久度最大值
		14:	装备序列号(可叠加物品慎用)

---------------------------------------

*existitem(<id>);
*existitem(<"name">);
	作用：	检测是否存在该物品。
		返回0，如果不存在。
		返回<道具id>，如果物品存在，且可以叠加。
		返回 - <道具id>，如果物品存在，且不能叠加。
	举例：  existitem("太阳眼镜") == -2201

---------------------------------------

*readbook <书id>,<页码>;
	作用：	通过脚本打开书并跳转到某页。

---------------------------------------

*query_sql2("<SQL语句>",<变量1>,<变量2>,……)
	作用：	采用角色服务器进行数据库操作，防止对大型数据库的操作使地图服务器停止响应。
		返回数据采用变量名+数字形式，取消128行限制，取消不能使用角色永久变量和
		帐号变量限制。
		函数将返回-1，如果角色服务器不在线；否则返回变量数。
	举例：
		set .@j,query_sql2("SELECT * FROM inventory i",$@myvar1,$@myvar2,$@myvar3,$@myvar4,$@myvar5,$@myvar6,$@myvar7,$@myvar8,$@myvar9,$@myvar10,$@myvar11,$@myvar12,$@myvar13);
		mes "数据库操作结束，得到"+.@j+"行，所有数据已经保存在内存中";
		mes "下面将通过mes显示所有数据，此过程会使客户端lag";
		next;
		for (set .@i,0; .@i<.@j; set .@i,.@i+1) 
		{
			mes getd("$@myvar1"+.@i)+"|"+getd("$@myvar2"+.@i)+"|"+getd("$@myvar3"+.@i)+"|"+getd("$@myvar4"+.@i)+"|"+getd("$@myvar5"+.@i)+"|"+getd("$@myvar6"+.@i)+"|"+getd("$@myvar7"+.@i)+"|"+getd("$@myvar8"+.@i)+"|"+getd("$@myvar9"+.@i)+"|"+getd("$@myvar10"+.@i)+"|"+getd("$@myvar11"+.@i)+"|"+getd("$@myvar12"+.@i)+"|"+getd("$@myvar13"+.@i)+"|";
			sleep2 1;
		}
		close;

---------------------------------------

*countpoints(<类型>);
	作用：	显示当前角色的卡普拉点数或金钱点数。未知类型返回-1。
	类型：	1 - 卡普拉点数；
		2 - 金钱点数。

---------------------------------------

*sendmail "<收件人姓名>","<标题>","<正文>",<zeny数量>,<物品id>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,"<发件人姓名>"};
	作用：	可以发匿名邮件，系统不会检测发件人姓名。常用于给不在线玩家发送物品。
		收件人姓名必须真实；
		发件人姓名可随意填写；
		发件人姓名不填写，则必须存在玩家脚本关联。

---------------------------------------

*resume <装备位置>, <时间>;
	作用：	续租某位置装备，时间单位为秒。
		装备不存在时返回-1，非租赁物品返回0，租赁装备返回续租后剩余租赁时间。
		时间可以为负数以缩短租赁时间。

---------------------------------------

*battleignore{ <标记>};
	作用：	怪物不会攻击你，标记为0时为取消，其他则进入该状态。

---------------------------------------

*warpignore{ <标记>};
	作用：	不会被传送，标记为0时为取消，其他则进入该状态。

---------------------------------------

*setoption1 <编号>;
	作用：	是对象进入指定状态。下表没有的编号，则默认为0
	类型列表：
		1 - 完全石化
		2 - 冰冻
		3 - 晕眩
		4 - 睡眠
		6 - 石化中

---------------------------------------

*setoption2 <编号>{,<标记>};
	作用：	标记不为0或没有标记，则使对象进入指定状态，标记为0则取消状态。
	类型列表：
		1  - 中毒
		2  - 诅咒
		4  - 沉默
		8  - 未知
		16 - 黑暗
		32 - 致命中毒

---------------------------------------

*campon "<地图名>"{,<标签>};
  campoff "<地图名>";
	作用：	打开或关闭无需按shift就能攻击的功能，只能攻击不同阵营的对象。
	类型：	标签为2时，地图显示伤害，否则则不显示。

---------------------------------------

*isrestricted <道具id>;
	作用：	如果物品在db\item_trade.txt设定为限制物品，则返回其限制内容；
		限制内容由1、2、8、16、32、64表示（具体限制对应参见db\item_trade.txt）
		否则，则返回0。如果物品不存在，则返回-1。

---------------------------------------

*islocked <道具id>;
	作用：	检查该玩家是否锁定该物品。
		是则返回1，否则，则返回0。
	注意：  如果身上有一件独立绑定的道具，该指令也会对该种类道具返回1；

---------------------------------------

*isrental <装备位置>;
	作用：	如果物品为租赁物品，则返回其剩余时间（秒）
		否则，则返回0；如果指定装备位置不正确，则返回-1。

---------------------------------------

*rentequip <道具id或道具名>,<精炼值>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<N秒后到期>{,<角色ID>};
	作用：	租赁指定的道具，任何装备都能通过此直接租赁.
		租赁物品自动成为无法交易，但可放手推车和个人仓库，逾期会自动删除。可以精炼，插卡。
	例如：	rentequip 2424,10,0,0,0,0,3600; 将租+10轻便鞋给玩家1小时。

---------------------------------------

*strcut(<文本>, <位置>{, <长度>})
	作用：	对"<文本>"截取在"<位置>"前的所有字符。
		<位置>最小为0；<长度>最小为1；如果不指定长度，默认为1。（兼容jA, CEA）
		如果指定“位置”不在文本长度内，则自动调整为最近的文本长度范围内的值。
		如果指定“长度”超过了文本长度，则自动调整为剩余文本长度。
	例如：	strcut(strcharinfo(4),6,3), 截取玩家ip的第7位（含第7位）之后的3个字符。
		即：如果ip为10.16.218.24，则返回218。

---------------------------------------

*campmob("<map name>",<spawn x>,<spawn y>,<target x>,<target y>,<monster name>,<monster id>,<monster camp>{,"<event>"})
	作用：	在指定地图指定位置创造一个魔物，并且能为该魔物指定阵营、行走目标坐标以及触发事件。
		魔物的出生坐标可以为0，即随即位置生成。魔物的目的坐标可以为0，即随即走动。魔物的出生坐标与目的坐标相同，即随即走动。
		如果魔物阵营为0，即普通怪物。如果魔物阵营不为0，则其会主动攻击有阵营且阵营不同的玩家（魔物状态必须是Aggressive）。
		该脚本会返回魔物GID，可用于mobattach魔物操控。如果魔物与npc关联，则最后的触发事件不会启动，必须使用Callback触发。
		该部分内容请见doc\script_command.txt，Mob Control Suit章节。

		r13D84新增内容：路点系统。
		<target x> 为 -1 时使用路点系统，<target y> 表示路点id，路点格式参照waypoint.txt

---------------------------------------

*getguildmember <guild id>,{<type>};
	作用：	该命令会得到如下信息的数列：
		$@guildmembername$[]	所有工会成员的名字（如果type为0或者没有设置）。
		$@guildmembercid[]	所有工会成员的CID（角色id）（如果type为1）。
		$@guildmemberaid[]	所有工会成员的AID（账号id）（如果type为2）。
		$@guildmembercount	工会成员数量（包括不在线）。

---------------------------------------

*buildbarricade, killbarricade
	buildbarricade("<地图名>",<坐标x>,<坐标y>,"<显示名>",<size>,<dir>,<killable>,<walkable>,<shootable>,<odd>,"<事件标签>")
	dir从正北（上）开始逆时针方向分别为0~7，size表示路障在所给坐标的某方向上扩展多少格，odd如果为1表示在奇数格子内显示路障，如果为0，则表示在偶数格内显示路障。
	killable表示是否能被攻击，walkable表示是否能行走穿过，shootable表示是否能穿过路障攻击或飞跃。他们的值皆为0或1。

---------------------------------------

*getbattlestatus <id>,<类型>

	ID为GID，即玩家时为AID。

	类型：
	1：str总值	2：agi总值	3：vit总值	4：int总值	5：dex总值
	6：luk总值	7：hp		8：maxhp	9：sp		10：maxsp
	11：左atk	12：左matk	13：右matk	14：移动速度	15：amotion
	16：adelay	17：dmotion	18：hit		19：flee	20：cri
	21：flee2	22：属性def	23：属性mdef	24：攻击速度倍率25：属性
	26：属性等级	27：装备def	28：装备mdef	29：右手武器atk	30：右手精炼atk
	31：右手武器属性32：右手武器距离33：左手武器atk	34：左右精炼atk	35：左右武器属性
	36：左手武器距离37：卡片atk	38：装备matk

	id或类型错误时，返回-1。	

---------------------------------------

*sc_check <type>{,<gid>}

	返回-1：找不到该角色。
	返回0：没有该状态。
	返回1：有该状态，并赋予下列变量值，变量意义自我解释，时间为-1表示无限。
		@sc_val1, @sc_val2, @sc_val3, @sc_val4, @sc_tickleft

---------------------------------------

*script4each "<脚本>",<类型>{,...}

	类型0：全服：script4each "<脚本>",0;
	类型1：全地图：script4each "<脚本>",1,"地图名";
	类型2：全区域：script4each "<脚本>",2,"地图名",坐标x,坐标y,范围;
	类型3：全组队：script4each "<脚本>",3,玩家cid; 
	类型4：全公会：script4each "<脚本>",4,玩家cid;
	类型5：全阵营：script4each "<脚本>",5,玩家cid;
	类型6：全区域：script4each "<脚本>",6,"地图名",坐标x0,坐标y0,坐标x1,坐标y1;

---------------------------------------

*script4eachmob "<脚本>",<类型>{,...}

	该命令仅支持setmobdata指令，setmobdata指令中的魔物GID请用变量“$@4eachmobgid”代替。

	类型0：全服：script4eachmob "<脚本>",0;
	类型1：全地图：script4eachmob "<脚本>",1,"地图名";
	类型2：全区域：script4eachmob "<脚本>",2,"地图名",坐标x0,坐标y0,坐标x1,坐标y1;
	类型5：全阵营：script4eachmob "<脚本>",3,阵营编号;

---------------------------------------

*noovercharge <id>{,<标识>}
*nodiscount <id>{,<标识>}

	标识0：关闭
	标识1：打开
	未指定默认1。

---------------------------------------

*checkalliance <公会id>

	返回1: 与此公会同盟
	返回0: 与此公会无关
	返回-1: 其他错误

---------------------------------------

*status_calc

举例: {
OnPCSCEndEvent:
OnPCSCStartEvent:
	status_calc();
	end;
OnPCStatCalcEvent:
	if(sc_check(SC_EDP))
	{
		bonus2 bSkillAtk,"GC_CROSSIMPACT",200;
		bonus2 bSkillAtk,"GC_COUNTERSLASH",200;
		bonus2 bSkillAtk,"AS_SONICBLOW",200;
		bonus2 bSkillAtk,"ASC_BREAKER",200;
	}
}

作用：致命吐毒对上述技能伤害翻倍。
---------------------------------------

*setaura <id>{,<周期>{,<id2>}{,<id3>}}

作用：设置光环效果。
id在effect_list.txt中查看。
周期毫秒记。0为不重复。
所有id共享同一周期。

---------------------------------------

*setnoks <gid>,<type>

	gid: 魔物id
	type: 0 - 关闭。1 - 自己。2 - 组队。 3 - 公会。 

作用：@noks的脚本指令版。设置不能被抢怪。

---------------------------------------

*processhalt;

作用：	在On*Event事件中终止后续运行。
	支持以下事件:
	OnPCUseSkillEvent
	OnNPCDropItemEvent
	OnPCUseItemEvent
	OnPCEquipItemEvent
	OnPCUnequipItemEvent
---------------------------------------

*viewequip <Aid>{,<flag>};

作用：	查看账号id为Aid的角色的装备。
	flag不为0时强制观看，否则要符合玩家的意愿或为GM。

---------------------------------------

*create_player "姓名", 职业ID, 性别, "地图名", x坐标, y坐标, 发型, 发色, 衣服颜色;

作用：	创造玩家。返回AID。

---------------------------------------

*create_vender AID, "招牌";

作用：	将给于AID的角色根据挂机重载的内容创造露天商店。

---------------------------------------

*cartgetitem2 "<Item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};

作用：	在手推车中得到物品，基本同getitem2.

---------------------------------------

*return2egg();

作用：	把宠物收起变成蛋。返回0，失败；返回1，成功。

---------------------------------------

*addshopentry("<NPC名>",<位置>,<id>,<价格>);

作用：	对商店或金钱商店的npc，添加贩卖道具。
说明：	位置从0开始。

---------------------------------------

*removeshopentry("<NPC名>",<id>);

作用：	对商店或金钱商店的npc，删除id道具的贩卖。

---------------------------------------

*setshopentry("<NPC名>",<id>,<price>);

作用：	对商店或金钱商店的npc，设置id道具的价格。

---------------------------------------

结束。
